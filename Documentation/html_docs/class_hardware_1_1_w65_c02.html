<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WolfNet 6502 WorkBench Computer Emulator: Hardware.W65C02 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="Style.css" rel="stylesheet" type="text/css" />
<link href="MyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WolfNet 6502 WorkBench Computer Emulator<span id="projectnumber">&#160;beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_hardware.html">Hardware</a></li><li class="navelem"><a class="el" href="class_hardware_1_1_w65_c02.html">W65C02</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_hardware_1_1_w65_c02-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Hardware.W65C02 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An implementation of a <a class="el" href="class_hardware_1_1_w65_c02.html" title="An implementation of a W65C02 Processor.">W65C02</a> Processor.   
 <a href="class_hardware_1_1_w65_c02.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86db392ae9eb672281ca9cdaff7eb369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a86db392ae9eb672281ca9cdaff7eb369.html#a86db392ae9eb672281ca9cdaff7eb369">W65C02</a> ()</td></tr>
<tr class="memdesc:a86db392ae9eb672281ca9cdaff7eb369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor, Instantiates a new instance of the processor.   <a href="class_hardware_1_1_w65_c02_a86db392ae9eb672281ca9cdaff7eb369.html#a86db392ae9eb672281ca9cdaff7eb369">More...</a><br /></td></tr>
<tr class="separator:a86db392ae9eb672281ca9cdaff7eb369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9768a473c3b12b4fac7154ee00850a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a9768a473c3b12b4fac7154ee00850a90.html#a9768a473c3b12b4fac7154ee00850a90">Reset</a> ()</td></tr>
<tr class="memdesc:a9768a473c3b12b4fac7154ee00850a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the processor to its default state.   <a href="class_hardware_1_1_w65_c02_a9768a473c3b12b4fac7154ee00850a90.html#a9768a473c3b12b4fac7154ee00850a90">More...</a><br /></td></tr>
<tr class="separator:a9768a473c3b12b4fac7154ee00850a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694c9c669ca2078f577ba1fe212c65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a2694c9c669ca2078f577ba1fe212c65e.html#a2694c9c669ca2078f577ba1fe212c65e">NextStep</a> ()</td></tr>
<tr class="memdesc:a2694c9c669ca2078f577ba1fe212c65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the next step on the processor   <a href="class_hardware_1_1_w65_c02_a2694c9c669ca2078f577ba1fe212c65e.html#a2694c9c669ca2078f577ba1fe212c65e">More...</a><br /></td></tr>
<tr class="separator:a2694c9c669ca2078f577ba1fe212c65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e519f1e532098b8d3441cd123cc891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a21e519f1e532098b8d3441cd123cc891.html#a21e519f1e532098b8d3441cd123cc891">InterruptRequest</a> ()</td></tr>
<tr class="memdesc:a21e519f1e532098b8d3441cd123cc891"><td class="mdescLeft">&#160;</td><td class="mdescRight">The InterruptRequest or IRQ   <a href="class_hardware_1_1_w65_c02_a21e519f1e532098b8d3441cd123cc891.html#a21e519f1e532098b8d3441cd123cc891">More...</a><br /></td></tr>
<tr class="separator:a21e519f1e532098b8d3441cd123cc891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab342c867fed7c221e8515f0ea08eabe0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ab342c867fed7c221e8515f0ea08eabe0.html#ab342c867fed7c221e8515f0ea08eabe0">GetCycleCount</a> ()</td></tr>
<tr class="memdesc:ab342c867fed7c221e8515f0ea08eabe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Number of Cycles that have elapsed   <a href="class_hardware_1_1_w65_c02_ab342c867fed7c221e8515f0ea08eabe0.html#ab342c867fed7c221e8515f0ea08eabe0">More...</a><br /></td></tr>
<tr class="separator:ab342c867fed7c221e8515f0ea08eabe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed967d6db628ec61f047dd0d79ca245"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_aeed967d6db628ec61f047dd0d79ca245.html#aeed967d6db628ec61f047dd0d79ca245">IncrementCycleCount</a> ()</td></tr>
<tr class="memdesc:aeed967d6db628ec61f047dd0d79ca245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the Cycle Count, causes a CycleCountIncrementedAction to fire.   <a href="class_hardware_1_1_w65_c02_aeed967d6db628ec61f047dd0d79ca245.html#aeed967d6db628ec61f047dd0d79ca245">More...</a><br /></td></tr>
<tr class="separator:aeed967d6db628ec61f047dd0d79ca245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31145d9a99afa514c339588e1cb42ac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a31145d9a99afa514c339588e1cb42ac8.html#a31145d9a99afa514c339588e1cb42ac8">ResetCycleCount</a> ()</td></tr>
<tr class="memdesc:a31145d9a99afa514c339588e1cb42ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the Cycle Count back to 0   <a href="class_hardware_1_1_w65_c02_a31145d9a99afa514c339588e1cb42ac8.html#a31145d9a99afa514c339588e1cb42ac8">More...</a><br /></td></tr>
<tr class="separator:a31145d9a99afa514c339588e1cb42ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b5fb6f1aabe49eb17022dc5f68d728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a82b5fb6f1aabe49eb17022dc5f68d728.html#a82b5fb6f1aabe49eb17022dc5f68d728">AslOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a82b5fb6f1aabe49eb17022dc5f68d728"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ASL - Shift Left One Bit (Memory or Accumulator)   <a href="class_hardware_1_1_w65_c02_a82b5fb6f1aabe49eb17022dc5f68d728.html#a82b5fb6f1aabe49eb17022dc5f68d728">More...</a><br /></td></tr>
<tr class="separator:a82b5fb6f1aabe49eb17022dc5f68d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aea5bad1eb73459933b9baf077b80a69d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_aea5bad1eb73459933b9baf077b80a69d.html#aea5bad1eb73459933b9baf077b80a69d">isRunning</a></td></tr>
<tr class="memdesc:aea5bad1eb73459933b9baf077b80a69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks shether the emulated computer is running or not.   <a href="class_hardware_1_1_w65_c02_aea5bad1eb73459933b9baf077b80a69d.html#aea5bad1eb73459933b9baf077b80a69d">More...</a><br /></td></tr>
<tr class="separator:aea5bad1eb73459933b9baf077b80a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab2dda1182961a15be691d895e3f3c4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ab2dda1182961a15be691d895e3f3c4b1.html#ab2dda1182961a15be691d895e3f3c4b1">SetNegativeFlag</a> (int value)</td></tr>
<tr class="memdesc:ab2dda1182961a15be691d895e3f3c4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IsSignNegative register   <a href="class_hardware_1_1_w65_c02_ab2dda1182961a15be691d895e3f3c4b1.html#ab2dda1182961a15be691d895e3f3c4b1">More...</a><br /></td></tr>
<tr class="separator:ab2dda1182961a15be691d895e3f3c4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53423ebf1b14c250ee208da8021e6e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a53423ebf1b14c250ee208da8021e6e31.html#a53423ebf1b14c250ee208da8021e6e31">SetZeroFlag</a> (int value)</td></tr>
<tr class="memdesc:a53423ebf1b14c250ee208da8021e6e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IsResultZero register   <a href="class_hardware_1_1_w65_c02_a53423ebf1b14c250ee208da8021e6e31.html#a53423ebf1b14c250ee208da8021e6e31">More...</a><br /></td></tr>
<tr class="separator:a53423ebf1b14c250ee208da8021e6e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ef46e724de47e6c7ab6b3cb77e9afe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ac0ef46e724de47e6c7ab6b3cb77e9afe.html#ac0ef46e724de47e6c7ab6b3cb77e9afe">GetAddressByAddressingMode</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:ac0ef46e724de47e6c7ab6b3cb77e9afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the AddressingMode to return the correct address based on the mode. Note: This method will not increment the program counter for any mode. Note: This method will return an error if called for either the immediate or accumulator modes.   <a href="class_hardware_1_1_w65_c02_ac0ef46e724de47e6c7ab6b3cb77e9afe.html#ac0ef46e724de47e6c7ab6b3cb77e9afe">More...</a><br /></td></tr>
<tr class="separator:ac0ef46e724de47e6c7ab6b3cb77e9afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0033cab6c609ab6856bd1abd3541b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a4f0033cab6c609ab6856bd1abd3541b0.html#a4f0033cab6c609ab6856bd1abd3541b0">AddWithCarryOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a4f0033cab6c609ab6856bd1abd3541b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ADC - Add Memory to Accumulator with Carry Operation   <a href="class_hardware_1_1_w65_c02_a4f0033cab6c609ab6856bd1abd3541b0.html#a4f0033cab6c609ab6856bd1abd3541b0">More...</a><br /></td></tr>
<tr class="separator:a4f0033cab6c609ab6856bd1abd3541b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7febe6ad17ff7032aa10712b09d774fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a7febe6ad17ff7032aa10712b09d774fb.html#a7febe6ad17ff7032aa10712b09d774fb">SubtractWithBorrowOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a7febe6ad17ff7032aa10712b09d774fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SBC operation. Performs a subtract with carry operation on the accumulator and a value in memory.   <a href="class_hardware_1_1_w65_c02_a7febe6ad17ff7032aa10712b09d774fb.html#a7febe6ad17ff7032aa10712b09d774fb">More...</a><br /></td></tr>
<tr class="separator:a7febe6ad17ff7032aa10712b09d774fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a4eec5b3efabf5175eaef145c3a886054"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a4eec5b3efabf5175eaef145c3a886054.html#a4eec5b3efabf5175eaef145c3a886054">Accumulator</a><code> [get, protected set]</code></td></tr>
<tr class="memdesc:a4eec5b3efabf5175eaef145c3a886054"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Accumulator. This value is implemented as an integer intead of a byte. This is done so we can detect wrapping of the value and set the correct number of cycles.   <a href="class_hardware_1_1_w65_c02_a4eec5b3efabf5175eaef145c3a886054.html#a4eec5b3efabf5175eaef145c3a886054">More...</a><br /></td></tr>
<tr class="separator:a4eec5b3efabf5175eaef145c3a886054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30549de0474b350b3fa8ca30714a652"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_aa30549de0474b350b3fa8ca30714a652.html#aa30549de0474b350b3fa8ca30714a652">XRegister</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:aa30549de0474b350b3fa8ca30714a652"><td class="mdescLeft">&#160;</td><td class="mdescRight">The X Index Register   <a href="class_hardware_1_1_w65_c02_aa30549de0474b350b3fa8ca30714a652.html#aa30549de0474b350b3fa8ca30714a652">More...</a><br /></td></tr>
<tr class="separator:aa30549de0474b350b3fa8ca30714a652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23427a87d4c5710bf18e0bc338badc50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a23427a87d4c5710bf18e0bc338badc50.html#a23427a87d4c5710bf18e0bc338badc50">YRegister</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:a23427a87d4c5710bf18e0bc338badc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Y Index Register   <a href="class_hardware_1_1_w65_c02_a23427a87d4c5710bf18e0bc338badc50.html#a23427a87d4c5710bf18e0bc338badc50">More...</a><br /></td></tr>
<tr class="separator:a23427a87d4c5710bf18e0bc338badc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2280e861529c00e5adca272a18a8df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a4f2280e861529c00e5adca272a18a8df.html#a4f2280e861529c00e5adca272a18a8df">CurrentOpCode</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:a4f2280e861529c00e5adca272a18a8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Current Op Code being executed by the system   <a href="class_hardware_1_1_w65_c02_a4f2280e861529c00e5adca272a18a8df.html#a4f2280e861529c00e5adca272a18a8df">More...</a><br /></td></tr>
<tr class="separator:a4f2280e861529c00e5adca272a18a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa88743b54b6e1a121c750786b314d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_hardware_1_1_disassembly.html">Disassembly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_aaa88743b54b6e1a121c750786b314d93.html#aaa88743b54b6e1a121c750786b314d93">CurrentDisassembly</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:aaa88743b54b6e1a121c750786b314d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disassembly of the current operation. This value is only set when the CPU is built in debug mode.   <a href="class_hardware_1_1_w65_c02_aaa88743b54b6e1a121c750786b314d93.html#aaa88743b54b6e1a121c750786b314d93">More...</a><br /></td></tr>
<tr class="separator:aaa88743b54b6e1a121c750786b314d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad953847ee02d563ea055be5f70976247"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ad953847ee02d563ea055be5f70976247.html#ad953847ee02d563ea055be5f70976247">ProgramCounter</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:ad953847ee02d563ea055be5f70976247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the Current Address of the instruction being executed by the system. The PC wraps when the value is greater than 65535, or less than 0.   <a href="class_hardware_1_1_w65_c02_ad953847ee02d563ea055be5f70976247.html#ad953847ee02d563ea055be5f70976247">More...</a><br /></td></tr>
<tr class="separator:ad953847ee02d563ea055be5f70976247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83aed13efee53d08984eeb08543f72b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ac83aed13efee53d08984eeb08543f72b.html#ac83aed13efee53d08984eeb08543f72b">StackPointer</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:ac83aed13efee53d08984eeb08543f72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the Current Position of the Stack. This value is a 00-FF value but is offset to point to the location in memory where the stack resides.   <a href="class_hardware_1_1_w65_c02_ac83aed13efee53d08984eeb08543f72b.html#ac83aed13efee53d08984eeb08543f72b">More...</a><br /></td></tr>
<tr class="separator:ac83aed13efee53d08984eeb08543f72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f347c2b1cbce3021eec9b560bf0d48"><td class="memItemLeft" align="right" valign="top">Action&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ad9f347c2b1cbce3021eec9b560bf0d48.html#ad9f347c2b1cbce3021eec9b560bf0d48">CycleCountIncrementedAction</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ad9f347c2b1cbce3021eec9b560bf0d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">An external action that occurs when the cycle count is incremented   <a href="class_hardware_1_1_w65_c02_ad9f347c2b1cbce3021eec9b560bf0d48.html#ad9f347c2b1cbce3021eec9b560bf0d48">More...</a><br /></td></tr>
<tr class="separator:ad9f347c2b1cbce3021eec9b560bf0d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a336b0ce4f4f4675a3cb673f776a08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a01a336b0ce4f4f4675a3cb673f776a08.html#a01a336b0ce4f4f4675a3cb673f776a08">CarryFlag</a><code> [get, protected set]</code></td></tr>
<tr class="memdesc:a01a336b0ce4f4f4675a3cb673f776a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the carry flag. when adding, if the result is greater than 255 or 99 in BCD Mode, then this bit is enabled. In subtraction this is reversed and set to false if a borrow is required IE the result is less than 0   <a href="class_hardware_1_1_w65_c02_a01a336b0ce4f4f4675a3cb673f776a08.html#a01a336b0ce4f4f4675a3cb673f776a08">More...</a><br /></td></tr>
<tr class="separator:a01a336b0ce4f4f4675a3cb673f776a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f3a6f47dd43adc8579121085ef96ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a62f3a6f47dd43adc8579121085ef96ce.html#a62f3a6f47dd43adc8579121085ef96ce">ZeroFlag</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:a62f3a6f47dd43adc8579121085ef96ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is true if one of the registers is set to zero.   <a href="class_hardware_1_1_w65_c02_a62f3a6f47dd43adc8579121085ef96ce.html#a62f3a6f47dd43adc8579121085ef96ce">More...</a><br /></td></tr>
<tr class="separator:a62f3a6f47dd43adc8579121085ef96ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65b4975a58f0332067377ab71455668"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ae65b4975a58f0332067377ab71455668.html#ae65b4975a58f0332067377ab71455668">DisableInterruptFlag</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:ae65b4975a58f0332067377ab71455668"><td class="mdescLeft">&#160;</td><td class="mdescRight">This determines if Interrupts are currently disabled. This flag is turned on during a reset to prevent an interrupt from occuring during startup/Initialization. If this flag is true, then the IRQ pin is ignored.   <a href="class_hardware_1_1_w65_c02_ae65b4975a58f0332067377ab71455668.html#ae65b4975a58f0332067377ab71455668">More...</a><br /></td></tr>
<tr class="separator:ae65b4975a58f0332067377ab71455668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42e58d4067c1f778bfdf87af8f0a87e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ad42e58d4067c1f778bfdf87af8f0a87e.html#ad42e58d4067c1f778bfdf87af8f0a87e">DecimalFlag</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:ad42e58d4067c1f778bfdf87af8f0a87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Coded Decimal Mode is set/cleared via this flag. when this mode is in effect, a byte represents a number from 0-99.   <a href="class_hardware_1_1_w65_c02_ad42e58d4067c1f778bfdf87af8f0a87e.html#ad42e58d4067c1f778bfdf87af8f0a87e">More...</a><br /></td></tr>
<tr class="separator:ad42e58d4067c1f778bfdf87af8f0a87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a99644c32735c4c267ec3205cc2143"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ae8a99644c32735c4c267ec3205cc2143.html#ae8a99644c32735c4c267ec3205cc2143">OverflowFlag</a><code> [get, protected set]</code></td></tr>
<tr class="memdesc:ae8a99644c32735c4c267ec3205cc2143"><td class="mdescLeft">&#160;</td><td class="mdescRight">This property is set when an overflow occurs. An overflow happens if the high bit(7) changes during the operation. Remember that values from 128-256 are negative values as the high bit is set to 1. Examples: 64 + 64 = -128 -128 + -128 = 0   <a href="class_hardware_1_1_w65_c02_ae8a99644c32735c4c267ec3205cc2143.html#ae8a99644c32735c4c267ec3205cc2143">More...</a><br /></td></tr>
<tr class="separator:ae8a99644c32735c4c267ec3205cc2143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af066a29f612f045f2d6a7f8e74bfc0c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_af066a29f612f045f2d6a7f8e74bfc0c0.html#af066a29f612f045f2d6a7f8e74bfc0c0">NegativeFlag</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:af066a29f612f045f2d6a7f8e74bfc0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if the result of an operation is negative in ADC and SBC operations. Remember that 128-256 represent negative numbers when doing signed math. In shift operations the sign holds the carry.   <a href="class_hardware_1_1_w65_c02_af066a29f612f045f2d6a7f8e74bfc0c0.html#af066a29f612f045f2d6a7f8e74bfc0c0">More...</a><br /></td></tr>
<tr class="separator:af066a29f612f045f2d6a7f8e74bfc0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dc12ac8300a711a59c8b3a39a50610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a14dc12ac8300a711a59c8b3a39a50610.html#a14dc12ac8300a711a59c8b3a39a50610">TriggerNmi</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a14dc12ac8300a711a59c8b3a39a50610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true when an NMI should occur   <a href="class_hardware_1_1_w65_c02_a14dc12ac8300a711a59c8b3a39a50610.html#a14dc12ac8300a711a59c8b3a39a50610">More...</a><br /></td></tr>
<tr class="separator:a14dc12ac8300a711a59c8b3a39a50610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af854675b2c983094976662f7351eb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a0af854675b2c983094976662f7351eb1.html#a0af854675b2c983094976662f7351eb1">TriggerIRQ</a><code> [get, private set]</code></td></tr>
<tr class="memdesc:a0af854675b2c983094976662f7351eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true when an IRQ has occurred and is being processed by the CPU.  <a href="class_hardware_1_1_w65_c02_a0af854675b2c983094976662f7351eb1.html#a0af854675b2c983094976662f7351eb1">More...</a><br /></td></tr>
<tr class="separator:a0af854675b2c983094976662f7351eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7ffb8ebc76f2e08ca2fd6b3be5271549"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a7ffb8ebc76f2e08ca2fd6b3be5271549.html#a7ffb8ebc76f2e08ca2fd6b3be5271549">ExecuteOpCode</a> ()</td></tr>
<tr class="memdesc:a7ffb8ebc76f2e08ca2fd6b3be5271549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes an Opcode   <a href="class_hardware_1_1_w65_c02_a7ffb8ebc76f2e08ca2fd6b3be5271549.html#a7ffb8ebc76f2e08ca2fd6b3be5271549">More...</a><br /></td></tr>
<tr class="separator:a7ffb8ebc76f2e08ca2fd6b3be5271549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b39c6ff9805646eb57d3af5a55762d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a09b39c6ff9805646eb57d3af5a55762d.html#a09b39c6ff9805646eb57d3af5a55762d">MoveProgramCounterByRelativeValue</a> (byte valueToMove)</td></tr>
<tr class="memdesc:a09b39c6ff9805646eb57d3af5a55762d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the ProgramCounter in a given direction based on the value inputted  <a href="class_hardware_1_1_w65_c02_a09b39c6ff9805646eb57d3af5a55762d.html#a09b39c6ff9805646eb57d3af5a55762d">More...</a><br /></td></tr>
<tr class="separator:a09b39c6ff9805646eb57d3af5a55762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd9fdfc619f1cc4ff3fb9e80a64db2e"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a2cd9fdfc619f1cc4ff3fb9e80a64db2e.html#a2cd9fdfc619f1cc4ff3fb9e80a64db2e">PeekStack</a> ()</td></tr>
<tr class="memdesc:a2cd9fdfc619f1cc4ff3fb9e80a64db2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a the value from the stack without changing the position of the stack pointer   <a href="class_hardware_1_1_w65_c02_a2cd9fdfc619f1cc4ff3fb9e80a64db2e.html#a2cd9fdfc619f1cc4ff3fb9e80a64db2e">More...</a><br /></td></tr>
<tr class="separator:a2cd9fdfc619f1cc4ff3fb9e80a64db2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321f88a43350d40d89cd91b32cfdae4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a321f88a43350d40d89cd91b32cfdae4e.html#a321f88a43350d40d89cd91b32cfdae4e">PokeStack</a> (byte value)</td></tr>
<tr class="memdesc:a321f88a43350d40d89cd91b32cfdae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value directly to the stack without modifying the Stack Pointer   <a href="class_hardware_1_1_w65_c02_a321f88a43350d40d89cd91b32cfdae4e.html#a321f88a43350d40d89cd91b32cfdae4e">More...</a><br /></td></tr>
<tr class="separator:a321f88a43350d40d89cd91b32cfdae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d9a8c47434d517c7b43f72a25d1031"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ad8d9a8c47434d517c7b43f72a25d1031.html#ad8d9a8c47434d517c7b43f72a25d1031">ConvertFlagsToByte</a> (bool setBreak)</td></tr>
<tr class="memdesc:ad8d9a8c47434d517c7b43f72a25d1031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coverts the Flags into its byte representation.   <a href="class_hardware_1_1_w65_c02_ad8d9a8c47434d517c7b43f72a25d1031.html#ad8d9a8c47434d517c7b43f72a25d1031">More...</a><br /></td></tr>
<tr class="separator:ad8d9a8c47434d517c7b43f72a25d1031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa515c8b0f2c41ac1c560e3a280f0c9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_aa515c8b0f2c41ac1c560e3a280f0c9d6.html#aa515c8b0f2c41ac1c560e3a280f0c9d6">SetDisassembly</a> ()</td></tr>
<tr class="separator:aa515c8b0f2c41ac1c560e3a280f0c9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f668cf0fadfb485fa479b9a20fa1f90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a3f668cf0fadfb485fa479b9a20fa1f90.html#a3f668cf0fadfb485fa479b9a20fa1f90">WrapProgramCounter</a> (int value)</td></tr>
<tr class="separator:a3f668cf0fadfb485fa479b9a20fa1f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54529fb64ab3001c221aec400fb50af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_af54529fb64ab3001c221aec400fb50af.html#af54529fb64ab3001c221aec400fb50af">GetAddressingMode</a> ()</td></tr>
<tr class="separator:af54529fb64ab3001c221aec400fb50af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33f788be5ee43a7b682933e2c4cedb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ad33f788be5ee43a7b682933e2c4cedb8.html#ad33f788be5ee43a7b682933e2c4cedb8">AndOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:ad33f788be5ee43a7b682933e2c4cedb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AND - Compare Memory with Accumulator operation   <a href="class_hardware_1_1_w65_c02_ad33f788be5ee43a7b682933e2c4cedb8.html#ad33f788be5ee43a7b682933e2c4cedb8">More...</a><br /></td></tr>
<tr class="separator:ad33f788be5ee43a7b682933e2c4cedb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3a441c64a7acc48f6ffc2953137732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_afc3a441c64a7acc48f6ffc2953137732.html#afc3a441c64a7acc48f6ffc2953137732">BranchOperation</a> (bool performBranch)</td></tr>
<tr class="memdesc:afc3a441c64a7acc48f6ffc2953137732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the different branch operations.   <a href="class_hardware_1_1_w65_c02_afc3a441c64a7acc48f6ffc2953137732.html#afc3a441c64a7acc48f6ffc2953137732">More...</a><br /></td></tr>
<tr class="separator:afc3a441c64a7acc48f6ffc2953137732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e38d5535c831ca61ddfe27c41a928c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a2e38d5535c831ca61ddfe27c41a928c9.html#a2e38d5535c831ca61ddfe27c41a928c9">BitOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a2e38d5535c831ca61ddfe27c41a928c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit operation, does an &amp; comparison between a value in memory and the accumulator   <a href="class_hardware_1_1_w65_c02_a2e38d5535c831ca61ddfe27c41a928c9.html#a2e38d5535c831ca61ddfe27c41a928c9">More...</a><br /></td></tr>
<tr class="separator:a2e38d5535c831ca61ddfe27c41a928c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba87339e072e5d850073a34168f3622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_adba87339e072e5d850073a34168f3622.html#adba87339e072e5d850073a34168f3622">CompareOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode, int comparisonValue)</td></tr>
<tr class="memdesc:adba87339e072e5d850073a34168f3622"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compare operation. This operation compares a value in memory with a value passed into it.   <a href="class_hardware_1_1_w65_c02_adba87339e072e5d850073a34168f3622.html#adba87339e072e5d850073a34168f3622">More...</a><br /></td></tr>
<tr class="separator:adba87339e072e5d850073a34168f3622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae242ed589a675afe35ae90836c9f0095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ae242ed589a675afe35ae90836c9f0095.html#ae242ed589a675afe35ae90836c9f0095">ChangeMemoryByOne</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode, bool decrement)</td></tr>
<tr class="memdesc:ae242ed589a675afe35ae90836c9f0095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a value in memory by 1   <a href="class_hardware_1_1_w65_c02_ae242ed589a675afe35ae90836c9f0095.html#ae242ed589a675afe35ae90836c9f0095">More...</a><br /></td></tr>
<tr class="separator:ae242ed589a675afe35ae90836c9f0095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1aabcf782a2741262e598d2edb4ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a2a1aabcf782a2741262e598d2edb4ae0.html#a2a1aabcf782a2741262e598d2edb4ae0">ChangeRegisterByOne</a> (bool useXRegister, bool decrement)</td></tr>
<tr class="memdesc:a2a1aabcf782a2741262e598d2edb4ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a value in either the X or Y register by 1   <a href="class_hardware_1_1_w65_c02_a2a1aabcf782a2741262e598d2edb4ae0.html#a2a1aabcf782a2741262e598d2edb4ae0">More...</a><br /></td></tr>
<tr class="separator:a2a1aabcf782a2741262e598d2edb4ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78adf3534a37bd429fbe35bad7e5824f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a78adf3534a37bd429fbe35bad7e5824f.html#a78adf3534a37bd429fbe35bad7e5824f">EorOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a78adf3534a37bd429fbe35bad7e5824f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EOR Operation, Performs an Exclusive OR Operation against the Accumulator and a value in memory   <a href="class_hardware_1_1_w65_c02_a78adf3534a37bd429fbe35bad7e5824f.html#a78adf3534a37bd429fbe35bad7e5824f">More...</a><br /></td></tr>
<tr class="separator:a78adf3534a37bd429fbe35bad7e5824f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a071807bfd5b62e07201e523682da37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a3a071807bfd5b62e07201e523682da37.html#a3a071807bfd5b62e07201e523682da37">LsrOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a3a071807bfd5b62e07201e523682da37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LSR Operation. Performs a Left shift operation on a value in memory   <a href="class_hardware_1_1_w65_c02_a3a071807bfd5b62e07201e523682da37.html#a3a071807bfd5b62e07201e523682da37">More...</a><br /></td></tr>
<tr class="separator:a3a071807bfd5b62e07201e523682da37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb359c71b333de2d37b93251cd43600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a1cb359c71b333de2d37b93251cd43600.html#a1cb359c71b333de2d37b93251cd43600">OrOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:a1cb359c71b333de2d37b93251cd43600"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Or Operation. Performs an Or Operation with the accumulator and a value in memory   <a href="class_hardware_1_1_w65_c02_a1cb359c71b333de2d37b93251cd43600.html#a1cb359c71b333de2d37b93251cd43600">More...</a><br /></td></tr>
<tr class="separator:a1cb359c71b333de2d37b93251cd43600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac913afa66fd38bb386848f002fe54996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ac913afa66fd38bb386848f002fe54996.html#ac913afa66fd38bb386848f002fe54996">RolOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:ac913afa66fd38bb386848f002fe54996"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ROL operation. Performs a rotate left operation on a value in memory.   <a href="class_hardware_1_1_w65_c02_ac913afa66fd38bb386848f002fe54996.html#ac913afa66fd38bb386848f002fe54996">More...</a><br /></td></tr>
<tr class="separator:ac913afa66fd38bb386848f002fe54996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b0452565df1ff90a8460b5bbf0b055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_af0b0452565df1ff90a8460b5bbf0b055.html#af0b0452565df1ff90a8460b5bbf0b055">RorOperation</a> (<a class="el" href="namespace_hardware_a20ed8885928dd1f3f9eac50507a162fc.html#a20ed8885928dd1f3f9eac50507a162fc">AddressingMode</a> addressingMode)</td></tr>
<tr class="memdesc:af0b0452565df1ff90a8460b5bbf0b055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ROR operation. Performs a rotate right operation on a value in memory.   <a href="class_hardware_1_1_w65_c02_af0b0452565df1ff90a8460b5bbf0b055.html#af0b0452565df1ff90a8460b5bbf0b055">More...</a><br /></td></tr>
<tr class="separator:af0b0452565df1ff90a8460b5bbf0b055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ff2524ce2f40600e3d5c68746e20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a527ff2524ce2f40600e3d5c68746e20d.html#a527ff2524ce2f40600e3d5c68746e20d">PushFlagsOperation</a> ()</td></tr>
<tr class="memdesc:a527ff2524ce2f40600e3d5c68746e20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PSP Operation. Pushes the Status Flags to the stack   <a href="class_hardware_1_1_w65_c02_a527ff2524ce2f40600e3d5c68746e20d.html#a527ff2524ce2f40600e3d5c68746e20d">More...</a><br /></td></tr>
<tr class="separator:a527ff2524ce2f40600e3d5c68746e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273907446550b31d4503bbf94dd8dac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a273907446550b31d4503bbf94dd8dac4.html#a273907446550b31d4503bbf94dd8dac4">PullFlagsOperation</a> ()</td></tr>
<tr class="memdesc:a273907446550b31d4503bbf94dd8dac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PLP Operation. Pull the status flags off the stack on sets the flags accordingly.   <a href="class_hardware_1_1_w65_c02_a273907446550b31d4503bbf94dd8dac4.html#a273907446550b31d4503bbf94dd8dac4">More...</a><br /></td></tr>
<tr class="separator:a273907446550b31d4503bbf94dd8dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e778668a5ade5d59900050deed5b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ac7e778668a5ade5d59900050deed5b7c.html#ac7e778668a5ade5d59900050deed5b7c">JumpToSubRoutineOperation</a> ()</td></tr>
<tr class="memdesc:ac7e778668a5ade5d59900050deed5b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The JSR routine. Jumps to a subroutine.   <a href="class_hardware_1_1_w65_c02_ac7e778668a5ade5d59900050deed5b7c.html#ac7e778668a5ade5d59900050deed5b7c">More...</a><br /></td></tr>
<tr class="separator:ac7e778668a5ade5d59900050deed5b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede15c7f042f61a2739aff59fe51e252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_aede15c7f042f61a2739aff59fe51e252.html#aede15c7f042f61a2739aff59fe51e252">ReturnFromSubRoutineOperation</a> ()</td></tr>
<tr class="memdesc:aede15c7f042f61a2739aff59fe51e252"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RTS routine. Called when returning from a subroutine.   <a href="class_hardware_1_1_w65_c02_aede15c7f042f61a2739aff59fe51e252.html#aede15c7f042f61a2739aff59fe51e252">More...</a><br /></td></tr>
<tr class="separator:aede15c7f042f61a2739aff59fe51e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c6db1a3b07bc79c629468f3b07bfda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a08c6db1a3b07bc79c629468f3b07bfda.html#a08c6db1a3b07bc79c629468f3b07bfda">BreakOperation</a> (bool isBrk, int vector)</td></tr>
<tr class="memdesc:a08c6db1a3b07bc79c629468f3b07bfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The BRK routine. Called when a BRK occurs.   <a href="class_hardware_1_1_w65_c02_a08c6db1a3b07bc79c629468f3b07bfda.html#a08c6db1a3b07bc79c629468f3b07bfda">More...</a><br /></td></tr>
<tr class="separator:a08c6db1a3b07bc79c629468f3b07bfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9552add73d52338f7201f524973d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a4d9552add73d52338f7201f524973d8e.html#a4d9552add73d52338f7201f524973d8e">ReturnFromInterruptOperation</a> ()</td></tr>
<tr class="memdesc:a4d9552add73d52338f7201f524973d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RTI routine. Called when returning from a BRK opertion. Note: when called after a BRK operation the Program Counter is not set to the location after the BRK, it is set +1   <a href="class_hardware_1_1_w65_c02_a4d9552add73d52338f7201f524973d8e.html#a4d9552add73d52338f7201f524973d8e">More...</a><br /></td></tr>
<tr class="separator:a4d9552add73d52338f7201f524973d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5acb4e41c75c252636eabcd8075c17f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ac5acb4e41c75c252636eabcd8075c17f.html#ac5acb4e41c75c252636eabcd8075c17f">ProcessNMI</a> ()</td></tr>
<tr class="memdesc:ac5acb4e41c75c252636eabcd8075c17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is ran anytime an NMI occurrs   <a href="class_hardware_1_1_w65_c02_ac5acb4e41c75c252636eabcd8075c17f.html#ac5acb4e41c75c252636eabcd8075c17f">More...</a><br /></td></tr>
<tr class="separator:ac5acb4e41c75c252636eabcd8075c17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad77199a7aa523c453ead06c3dc62ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_acad77199a7aa523c453ead06c3dc62ac.html#acad77199a7aa523c453ead06c3dc62ac">ProcessIRQ</a> ()</td></tr>
<tr class="memdesc:acad77199a7aa523c453ead06c3dc62ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is ran anytime an IRQ occurrs   <a href="class_hardware_1_1_w65_c02_acad77199a7aa523c453ead06c3dc62ac.html#acad77199a7aa523c453ead06c3dc62ac">More...</a><br /></td></tr>
<tr class="separator:acad77199a7aa523c453ead06c3dc62ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a80966ec7e9c6dba1f3586ed0e9f80cc1"><td class="memItemLeft" align="right" valign="top">readonly ILogger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a80966ec7e9c6dba1f3586ed0e9f80cc1.html#a80966ec7e9c6dba1f3586ed0e9f80cc1">_logger</a> = LogManager.GetLogger(&quot;Processor&quot;)</td></tr>
<tr class="separator:a80966ec7e9c6dba1f3586ed0e9f80cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae180656bffc65257a3656e69f63aee79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_ae180656bffc65257a3656e69f63aee79.html#ae180656bffc65257a3656e69f63aee79">_programCounter</a></td></tr>
<tr class="separator:ae180656bffc65257a3656e69f63aee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a8b12df740a0135197860cc854ceed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a42a8b12df740a0135197860cc854ceed.html#a42a8b12df740a0135197860cc854ceed">_stackPointer</a></td></tr>
<tr class="separator:a42a8b12df740a0135197860cc854ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1887c3c32e8f0916851b15c376fd6f88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a1887c3c32e8f0916851b15c376fd6f88.html#a1887c3c32e8f0916851b15c376fd6f88">_cycleCount</a></td></tr>
<tr class="separator:a1887c3c32e8f0916851b15c376fd6f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27df02bea5ab70320301aa322bdf50a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_af27df02bea5ab70320301aa322bdf50a.html#af27df02bea5ab70320301aa322bdf50a">_previousInterrupt</a></td></tr>
<tr class="separator:af27df02bea5ab70320301aa322bdf50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01ed5f12d89a4f323afbf661a9e348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hardware_1_1_w65_c02_a4e01ed5f12d89a4f323afbf661a9e348.html#a4e01ed5f12d89a4f323afbf661a9e348">_interrupt</a></td></tr>
<tr class="separator:a4e01ed5f12d89a4f323afbf661a9e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An implementation of a <a class="el" href="class_hardware_1_1_w65_c02.html" title="An implementation of a W65C02 Processor.">W65C02</a> Processor.  </p>

<p class="definition">Definition at line <a class="el" href="_w65_c02_8cs_source.html#l00013">13</a> of file <a class="el" href="_w65_c02_8cs_source.html">W65C02.cs</a>.</p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>Hardware/<a class="el" href="_w65_c02_8cs_source.html">W65C02.cs</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
