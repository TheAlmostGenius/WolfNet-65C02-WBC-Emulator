.TH "Hardware.W65C02" 3 "Sat Sep 24 2022" "Version beta" "WolfNet 6502 WorkBench Computer Emulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Hardware.W65C02 \- An implementation of a \fBW65C02\fP Processor\&.   

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBW65C02\fP ()"
.br
.RI "Default Constructor, Instantiates a new instance of the processor\&.  "
.ti -1c
.RI "void \fBReset\fP ()"
.br
.RI "Initializes the processor to its default state\&.  "
.ti -1c
.RI "void \fBNextStep\fP ()"
.br
.RI "Performs the next step on the processor  "
.ti -1c
.RI "void \fBInterruptRequest\fP ()"
.br
.RI "The InterruptRequest or IRQ  "
.ti -1c
.RI "int \fBGetCycleCount\fP ()"
.br
.RI "Gets the Number of Cycles that have elapsed  "
.ti -1c
.RI "void \fBIncrementCycleCount\fP ()"
.br
.RI "Increments the Cycle Count, causes a CycleCountIncrementedAction to fire\&.  "
.ti -1c
.RI "void \fBResetCycleCount\fP ()"
.br
.RI "Resets the Cycle Count back to 0  "
.ti -1c
.RI "void \fBAslOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ASL - Shift Left One Bit (Memory or Accumulator)  "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBisRunning\fP"
.br
.RI "Checks shether the emulated computer is running or not\&.  "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBSetNegativeFlag\fP (int value)"
.br
.RI "Sets the IsSignNegative register  "
.ti -1c
.RI "void \fBSetZeroFlag\fP (int value)"
.br
.RI "Sets the IsResultZero register  "
.ti -1c
.RI "int \fBGetAddressByAddressingMode\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "Uses the AddressingMode to return the correct address based on the mode\&. Note: This method will not increment the program counter for any mode\&. Note: This method will return an error if called for either the immediate or accumulator modes\&.  "
.ti -1c
.RI "void \fBAddWithCarryOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ADC - Add Memory to Accumulator with Carry Operation  "
.ti -1c
.RI "void \fBSubtractWithBorrowOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The SBC operation\&. Performs a subtract with carry operation on the accumulator and a value in memory\&.  "
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "int \fBAccumulator\fP\fC [get, protected set]\fP"
.br
.RI "The Accumulator\&. This value is implemented as an integer intead of a byte\&. This is done so we can detect wrapping of the value and set the correct number of cycles\&.  "
.ti -1c
.RI "int \fBXRegister\fP\fC [get, private set]\fP"
.br
.RI "The X Index Register  "
.ti -1c
.RI "int \fBYRegister\fP\fC [get, private set]\fP"
.br
.RI "The Y Index Register  "
.ti -1c
.RI "int \fBCurrentOpCode\fP\fC [get, private set]\fP"
.br
.RI "The Current Op Code being executed by the system  "
.ti -1c
.RI "\fBDisassembly\fP \fBCurrentDisassembly\fP\fC [get, private set]\fP"
.br
.RI "The disassembly of the current operation\&. This value is only set when the CPU is built in debug mode\&.  "
.ti -1c
.RI "int \fBProgramCounter\fP\fC [get, private set]\fP"
.br
.RI "Points to the Current Address of the instruction being executed by the system\&. The PC wraps when the value is greater than 65535, or less than 0\&.  "
.ti -1c
.RI "int \fBStackPointer\fP\fC [get, private set]\fP"
.br
.RI "Points to the Current Position of the Stack\&. This value is a 00-FF value but is offset to point to the location in memory where the stack resides\&.  "
.ti -1c
.RI "Action \fBCycleCountIncrementedAction\fP\fC [get, set]\fP"
.br
.RI "An external action that occurs when the cycle count is incremented  "
.ti -1c
.RI "bool \fBCarryFlag\fP\fC [get, protected set]\fP"
.br
.RI "This is the carry flag\&. when adding, if the result is greater than 255 or 99 in BCD Mode, then this bit is enabled\&. In subtraction this is reversed and set to false if a borrow is required IE the result is less than 0  "
.ti -1c
.RI "bool \fBZeroFlag\fP\fC [get, private set]\fP"
.br
.RI "Is true if one of the registers is set to zero\&.  "
.ti -1c
.RI "bool \fBDisableInterruptFlag\fP\fC [get, private set]\fP"
.br
.RI "This determines if Interrupts are currently disabled\&. This flag is turned on during a reset to prevent an interrupt from occuring during startup/Initialization\&. If this flag is true, then the IRQ pin is ignored\&.  "
.ti -1c
.RI "bool \fBDecimalFlag\fP\fC [get, private set]\fP"
.br
.RI "Binary Coded Decimal Mode is set/cleared via this flag\&. when this mode is in effect, a byte represents a number from 0-99\&.  "
.ti -1c
.RI "bool \fBOverflowFlag\fP\fC [get, protected set]\fP"
.br
.RI "This property is set when an overflow occurs\&. An overflow happens if the high bit(7) changes during the operation\&. Remember that values from 128-256 are negative values as the high bit is set to 1\&. Examples: 64 + 64 = -128 -128 + -128 = 0  "
.ti -1c
.RI "bool \fBNegativeFlag\fP\fC [get, private set]\fP"
.br
.RI "Set to true if the result of an operation is negative in ADC and SBC operations\&. Remember that 128-256 represent negative numbers when doing signed math\&. In shift operations the sign holds the carry\&.  "
.ti -1c
.RI "bool \fBTriggerNmi\fP\fC [get, set]\fP"
.br
.RI "Set to true when an NMI should occur  "
.ti -1c
.RI "bool \fBTriggerIRQ\fP\fC [get, private set]\fP"
.br
.RI "Set to true when an IRQ has occurred and is being processed by the CPU\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBExecuteOpCode\fP ()"
.br
.RI "Executes an Opcode  "
.ti -1c
.RI "void \fBMoveProgramCounterByRelativeValue\fP (byte valueToMove)"
.br
.RI "Moves the ProgramCounter in a given direction based on the value inputted "
.ti -1c
.RI "byte \fBPeekStack\fP ()"
.br
.RI "Returns a the value from the stack without changing the position of the stack pointer  "
.ti -1c
.RI "void \fBPokeStack\fP (byte value)"
.br
.RI "Write a value directly to the stack without modifying the Stack Pointer  "
.ti -1c
.RI "byte \fBConvertFlagsToByte\fP (bool setBreak)"
.br
.RI "Coverts the Flags into its byte representation\&.  "
.ti -1c
.RI "void \fBSetDisassembly\fP ()"
.br
.ti -1c
.RI "int \fBWrapProgramCounter\fP (int value)"
.br
.ti -1c
.RI "\fBAddressingMode\fP \fBGetAddressingMode\fP ()"
.br
.ti -1c
.RI "void \fBAndOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The AND - Compare Memory with Accumulator operation  "
.ti -1c
.RI "void \fBBranchOperation\fP (bool performBranch)"
.br
.RI "Performs the different branch operations\&.  "
.ti -1c
.RI "void \fBBitOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The bit operation, does an & comparison between a value in memory and the accumulator  "
.ti -1c
.RI "void \fBCompareOperation\fP (\fBAddressingMode\fP addressingMode, int comparisonValue)"
.br
.RI "The compare operation\&. This operation compares a value in memory with a value passed into it\&.  "
.ti -1c
.RI "void \fBChangeMemoryByOne\fP (\fBAddressingMode\fP addressingMode, bool decrement)"
.br
.RI "Changes a value in memory by 1  "
.ti -1c
.RI "void \fBChangeRegisterByOne\fP (bool useXRegister, bool decrement)"
.br
.RI "Changes a value in either the X or Y register by 1  "
.ti -1c
.RI "void \fBEorOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The EOR Operation, Performs an Exclusive OR Operation against the Accumulator and a value in memory  "
.ti -1c
.RI "void \fBLsrOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The LSR Operation\&. Performs a Left shift operation on a value in memory  "
.ti -1c
.RI "void \fBOrOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The Or Operation\&. Performs an Or Operation with the accumulator and a value in memory  "
.ti -1c
.RI "void \fBRolOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ROL operation\&. Performs a rotate left operation on a value in memory\&.  "
.ti -1c
.RI "void \fBRorOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ROR operation\&. Performs a rotate right operation on a value in memory\&.  "
.ti -1c
.RI "void \fBPushFlagsOperation\fP ()"
.br
.RI "The PSP Operation\&. Pushes the Status Flags to the stack  "
.ti -1c
.RI "void \fBPullFlagsOperation\fP ()"
.br
.RI "The PLP Operation\&. Pull the status flags off the stack on sets the flags accordingly\&.  "
.ti -1c
.RI "void \fBJumpToSubRoutineOperation\fP ()"
.br
.RI "The JSR routine\&. Jumps to a subroutine\&.  "
.ti -1c
.RI "void \fBReturnFromSubRoutineOperation\fP ()"
.br
.RI "The RTS routine\&. Called when returning from a subroutine\&.  "
.ti -1c
.RI "void \fBBreakOperation\fP (bool isBrk, int vector)"
.br
.RI "The BRK routine\&. Called when a BRK occurs\&.  "
.ti -1c
.RI "void \fBReturnFromInterruptOperation\fP ()"
.br
.RI "The RTI routine\&. Called when returning from a BRK opertion\&. Note: when called after a BRK operation the Program Counter is not set to the location after the BRK, it is set +1  "
.ti -1c
.RI "void \fBProcessNMI\fP ()"
.br
.RI "This is ran anytime an NMI occurrs  "
.ti -1c
.RI "void \fBProcessIRQ\fP ()"
.br
.RI "This is ran anytime an IRQ occurrs  "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "readonly ILogger \fB_logger\fP = LogManager\&.GetLogger('Processor')"
.br
.ti -1c
.RI "int \fB_programCounter\fP"
.br
.ti -1c
.RI "int \fB_stackPointer\fP"
.br
.ti -1c
.RI "int \fB_cycleCount\fP"
.br
.ti -1c
.RI "bool \fB_previousInterrupt\fP"
.br
.ti -1c
.RI "bool \fB_interrupt\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
An implementation of a \fBW65C02\fP Processor\&.  
.PP
Definition at line \fB13\fP of file \fBW65C02\&.cs\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Hardware\&.W65C02\&.W65C02 ()\fC [inline]\fP"

.PP
Default Constructor, Instantiates a new instance of the processor\&.  
.PP
Definition at line \fB143\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
144         {
145             StackPointer = 0x100;
146             CycleCountIncrementedAction = () => { };
147         }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Hardware\&.W65C02\&.AddWithCarryOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [protected]\fP"

.PP
The ADC - Add Memory to Accumulator with Carry Operation  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode used to perform this operation\&.
.RE
.PP

.PP
Definition at line \fB1888\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1889         {
1890             //Accumulator, Carry = Accumulator + ValueInMemoryLocation + Carry 
1891             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
1892             var newValue = memoryValue + Accumulator + (CarryFlag ? 1 : 0);
1893 
1894 
1895             OverflowFlag = (((Accumulator ^ newValue) & 0x80) != 0) && (((Accumulator ^ memoryValue) & 0x80) == 0);
1896 
1897             if (DecimalFlag)
1898             {
1899                 newValue = int\&.Parse(memoryValue\&.ToString("x")) + int\&.Parse(Accumulator\&.ToString("x")) + (CarryFlag ? 1 : 0);
1900 
1901                 if (newValue > 99)
1902                 {
1903                     CarryFlag = true;
1904                     newValue -= 100;
1905                 }
1906                 else
1907                 {
1908                     CarryFlag = false;
1909                 }
1910 
1911                 newValue = (int)Convert\&.ToInt64(string\&.Concat("0x", newValue), 16);
1912             }
1913             else
1914             {
1915                 if (newValue > 255)
1916                 {
1917                     CarryFlag = true;
1918                     newValue -= 256;
1919                 }
1920                 else
1921                 {
1922                     CarryFlag = false;
1923                 }
1924             }
1925 
1926             SetZeroFlag(newValue);
1927             SetNegativeFlag(newValue);
1928 
1929             Accumulator = newValue;
1930         }
.fi
.SS "void Hardware\&.W65C02\&.AndOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The AND - Compare Memory with Accumulator operation  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode being used
.RE
.PP

.PP
Definition at line \fB1936\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1937         {
1938             Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode)) & Accumulator;
1939 
1940             SetZeroFlag(Accumulator);
1941             SetNegativeFlag(Accumulator);
1942         }
.fi
.SS "void Hardware\&.W65C02\&.AslOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP"

.PP
The ASL - Shift Left One Bit (Memory or Accumulator)  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing Mode being used
.RE
.PP

.PP
Definition at line \fB1948\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1949         {
1950             int value;
1951             var memoryAddress = 0;
1952             if (addressingMode == AddressingMode\&.Accumulator)
1953             {
1954                 MemoryMap\&.Read(ProgramCounter + 1);
1955                 value = Accumulator;
1956             }
1957             else
1958             {
1959                 memoryAddress = GetAddressByAddressingMode(addressingMode);
1960                 value = MemoryMap\&.Read(memoryAddress);
1961             }
1962 
1963             //Dummy Write
1964             if (addressingMode != AddressingMode\&.Accumulator)
1965             {
1966                 MemoryMap\&.Write(memoryAddress, (byte)value);
1967             }
1968 
1969             //If the 7th bit is set, then we have a carry
1970             CarryFlag = ((value & 0x80) != 0);
1971 
1972             //The And here ensures that if the value is greater than 255 it wraps properly\&.
1973             value = (value << 1) & 0xFE;
1974 
1975             SetNegativeFlag(value);
1976             SetZeroFlag(value);
1977 
1978 
1979             if (addressingMode == AddressingMode\&.Accumulator)
1980                 Accumulator = value;
1981             else
1982             {
1983                 MemoryMap\&.Write(memoryAddress, (byte)value);
1984             }
1985         }
.fi
.SS "void Hardware\&.W65C02\&.BitOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The bit operation, does an & comparison between a value in memory and the accumulator  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP 
.RE
.PP

.PP
Definition at line \fB2008\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2009         {
2010 
2011             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2012             var valueToCompare = memoryValue & Accumulator;
2013 
2014             OverflowFlag = (memoryValue & 0x40) != 0;
2015 
2016             SetNegativeFlag(memoryValue);
2017             SetZeroFlag(valueToCompare);
2018         }
.fi
.SS "void Hardware\&.W65C02\&.BranchOperation (bool performBranch)\fC [inline]\fP, \fC [private]\fP"

.PP
Performs the different branch operations\&.  
.PP
\fBParameters\fP
.RS 4
\fIperformBranch\fP Is a branch required
.RE
.PP

.PP
Definition at line \fB1991\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1992         {
1993             var value = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Relative));
1994 
1995             if (!performBranch)
1996             {
1997                 ProgramCounter++;
1998                 return;
1999             }
2000 
2001             MoveProgramCounterByRelativeValue(value);
2002         }
.fi
.SS "void Hardware\&.W65C02\&.BreakOperation (bool isBrk, int vector)\fC [inline]\fP, \fC [private]\fP"

.PP
The BRK routine\&. Called when a BRK occurs\&.  
.PP
Definition at line \fB2354\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2355         {
2356             MemoryMap\&.Read(++ProgramCounter);
2357 
2358             //Put the high value on the stack
2359             //When we RTI the address will be incremented by one, and the address after a break will not be used\&.
2360             PokeStack((byte)(((ProgramCounter) >> 8) & 0xFF));
2361             StackPointer--;
2362             IncrementCycleCount();
2363 
2364             //Put the low value on the stack
2365             PokeStack((byte)((ProgramCounter) & 0xFF));
2366             StackPointer--;
2367             IncrementCycleCount();
2368 
2369             //We only set the Break Flag is a Break Occurs
2370             if (isBrk)
2371                 PokeStack((byte)(ConvertFlagsToByte(true) | 0x10));
2372             else
2373                 PokeStack(ConvertFlagsToByte(false));
2374 
2375             StackPointer--;
2376             IncrementCycleCount();
2377 
2378             DisableInterruptFlag = true;
2379 
2380             ProgramCounter = (MemoryMap\&.Read(vector + 1) << 8) | MemoryMap\&.Read(vector);
2381 
2382             _previousInterrupt = false;
2383         }
.fi
.SS "void Hardware\&.W65C02\&.ChangeMemoryByOne (\fBAddressingMode\fP addressingMode, bool decrement)\fC [inline]\fP, \fC [private]\fP"

.PP
Changes a value in memory by 1  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.br
\fIdecrement\fP If the operation is decrementing or incrementing the vaulue by 1 
.RE
.PP

.PP
Definition at line \fB2044\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2045         {
2046             var memoryLocation = GetAddressByAddressingMode(addressingMode);
2047             var memory = MemoryMap\&.Read(memoryLocation);
2048 
2049             MemoryMap\&.Write(memoryLocation, memory);
2050 
2051             if (decrement)
2052                 memory -= 1;
2053             else
2054                 memory += 1;
2055 
2056             SetZeroFlag(memory);
2057             SetNegativeFlag(memory);
2058 
2059 
2060             MemoryMap\&.Write(memoryLocation, memory);
2061         }
.fi
.SS "void Hardware\&.W65C02\&.ChangeRegisterByOne (bool useXRegister, bool decrement)\fC [inline]\fP, \fC [private]\fP"

.PP
Changes a value in either the X or Y register by 1  
.PP
\fBParameters\fP
.RS 4
\fIuseXRegister\fP If the operation is using the X or Y register
.br
\fIdecrement\fP If the operation is decrementing or incrementing the vaulue by 1 
.RE
.PP

.PP
Definition at line \fB2068\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2069         {
2070             var value = useXRegister ? XRegister : YRegister;
2071 
2072             if (decrement)
2073                 value -= 1;
2074             else
2075                 value += 1;
2076 
2077             if (value < 0x00)
2078                 value += 0x100;
2079             else if (value > 0xFF)
2080                 value -= 0x100;
2081 
2082             SetZeroFlag(value);
2083             SetNegativeFlag(value);
2084             IncrementCycleCount();
2085 
2086             if (useXRegister)
2087                 XRegister = value;
2088             else
2089                 YRegister = value;
2090         }
.fi
.SS "void Hardware\&.W65C02\&.CompareOperation (\fBAddressingMode\fP addressingMode, int comparisonValue)\fC [inline]\fP, \fC [private]\fP"

.PP
The compare operation\&. This operation compares a value in memory with a value passed into it\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.br
\fIcomparisonValue\fP The value to compare against memory
.RE
.PP

.PP
Definition at line \fB2025\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2026         {
2027             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2028             var comparedValue = comparisonValue - memoryValue;
2029 
2030             if (comparedValue < 0)
2031                 comparedValue += 0x10000;
2032 
2033             SetZeroFlag(comparedValue);
2034 
2035             CarryFlag = memoryValue <= comparisonValue;
2036             SetNegativeFlag(comparedValue);
2037         }
.fi
.SS "byte Hardware\&.W65C02\&.ConvertFlagsToByte (bool setBreak)\fC [inline]\fP, \fC [private]\fP"

.PP
Coverts the Flags into its byte representation\&.  
.PP
\fBParameters\fP
.RS 4
\fIsetBreak\fP Determines if the break flag should be set during conversion\&. IRQ does not set the flag on the stack, but PHP and BRK do
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB1522\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1523         {
1524             return (byte)((CarryFlag ? 0x01 : 0) + (ZeroFlag ? 0x02 : 0) + (DisableInterruptFlag ? 0x04 : 0) +
1525                 (DecimalFlag ? 8 : 0) + (setBreak ? 0x10 : 0) + 0x20 + (OverflowFlag ? 0x40 : 0) + (NegativeFlag ? 0x80 : 0));
1526         }
.fi
.SS "void Hardware\&.W65C02\&.EorOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The EOR Operation, Performs an Exclusive OR Operation against the Accumulator and a value in memory  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2096\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2097         {
2098             Accumulator = Accumulator ^ MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2099 
2100             SetNegativeFlag(Accumulator);
2101             SetZeroFlag(Accumulator);
2102         }
.fi
.SS "void Hardware\&.W65C02\&.ExecuteOpCode ()\fC [inline]\fP, \fC [private]\fP"

.PP
Executes an Opcode  
.PP
Definition at line \fB239\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
240         {
241             //The x+ cycles denotes that if a page wrap occurs, then an additional cycle is consumed\&.
242             //The x++ cycles denotes that 1 cycle is added when a branch occurs and it on the same page, and two cycles are added if its on a different page\&./
243             //This is handled inside the GetValueFromMemory Method
244             switch (CurrentOpCode)
245             {
246                 #region Add / Subtract Operations
247                 //ADC Add With Carry, Immediate, 2 Bytes, 2 Cycles
248                 case 0x69:
249                     {
250                         AddWithCarryOperation(AddressingMode\&.Immediate);
251                         break;
252                     }
253                 //ADC Add With Carry, Zero Page, 2 Bytes, 3 Cycles
254                 case 0x65:
255                     {
256                         AddWithCarryOperation(AddressingMode\&.ZeroPage);
257                         break;
258                     }
259                 //ADC Add With Carry, Zero Page X, 2 Bytes, 4 Cycles
260                 case 0x75:
261                     {
262                         AddWithCarryOperation(AddressingMode\&.ZeroPageX);
263                         break;
264                     }
265                 //ADC Add With Carry, Absolute, 3 Bytes, 4 Cycles
266                 case 0x6D:
267                     {
268                         AddWithCarryOperation(AddressingMode\&.Absolute);
269                         break;
270                     }
271                 //ADC Add With Carry, Absolute X, 3 Bytes, 4+ Cycles
272                 case 0x7D:
273                     {
274                         AddWithCarryOperation(AddressingMode\&.AbsoluteX);
275                         break;
276                     }
277                 //ADC Add With Carry, Absolute Y, 3 Bytes, 4+ Cycles
278                 case 0x79:
279                     {
280                         AddWithCarryOperation(AddressingMode\&.AbsoluteY);
281                         break;
282                     }
283                 //ADC Add With Carry, Indexed Indirect, 2 Bytes, 6 Cycles
284                 case 0x61:
285                     {
286                         AddWithCarryOperation(AddressingMode\&.IndirectX);
287                         break;
288                     }
289                 //ADC Add With Carry, Indexed Indirect, 2 Bytes, 5+ Cycles
290                 case 0x71:
291                     {
292                         AddWithCarryOperation(AddressingMode\&.IndirectY);
293                         break;
294                     }
295                 //SBC Subtract with Borrow, Immediate, 2 Bytes, 2 Cycles
296                 case 0xE9:
297                     {
298                         SubtractWithBorrowOperation(AddressingMode\&.Immediate);
299                         break;
300                     }
301                 //SBC Subtract with Borrow, Zero Page, 2 Bytes, 3 Cycles
302                 case 0xE5:
303                     {
304                         SubtractWithBorrowOperation(AddressingMode\&.ZeroPage);
305                         break;
306                     }
307                 //SBC Subtract with Borrow, Zero Page X, 2 Bytes, 4 Cycles
308                 case 0xF5:
309                     {
310                         SubtractWithBorrowOperation(AddressingMode\&.ZeroPageX);
311                         break;
312                     }
313                 //SBC Subtract with Borrow, Absolute, 3 Bytes, 4 Cycles
314                 case 0xED:
315                     {
316                         SubtractWithBorrowOperation(AddressingMode\&.Absolute);
317                         break;
318                     }
319                 //SBC Subtract with Borrow, Absolute X, 3 Bytes, 4+ Cycles
320                 case 0xFD:
321                     {
322                         SubtractWithBorrowOperation(AddressingMode\&.AbsoluteX);
323                         break;
324                     }
325                 //SBC Subtract with Borrow, Absolute Y, 3 Bytes, 4+ Cycles
326                 case 0xF9:
327                     {
328                         SubtractWithBorrowOperation(AddressingMode\&.AbsoluteY);
329                         break;
330                     }
331                 //SBC Subtract with Borrow, Indexed Indirect, 2 Bytes, 6 Cycles
332                 case 0xE1:
333                     {
334                         SubtractWithBorrowOperation(AddressingMode\&.IndirectX);
335                         break;
336                     }
337                 //SBC Subtract with Borrow, Indexed Indirect, 2 Bytes, 5+ Cycles
338                 case 0xF1:
339                     {
340                         SubtractWithBorrowOperation(AddressingMode\&.IndirectY);
341                         break;
342                     }
343                 #endregion
344 
345                 #region Branch Operations
346                 //BCC Branch if Carry is Clear, Relative, 2 Bytes, 2++ Cycles
347                 case 0x90:
348                     {
349                         BranchOperation(!CarryFlag);
350                         break;
351 
352                     }
353                 //BCS Branch if Carry is Set, Relative, 2 Bytes, 2++ Cycles
354                 case 0xB0:
355                     {
356                         BranchOperation(CarryFlag);
357                         break;
358                     }
359                 //BEQ Branch if Zero is Set, Relative, 2 Bytes, 2++ Cycles
360                 case 0xF0:
361                     {
362                         BranchOperation(ZeroFlag);
363                         break;
364                     }
365 
366                 // BMI Branch if Negative Set
367                 case 0x30:
368                     {
369                         BranchOperation(NegativeFlag);
370                         break;
371                     }
372                 //BNE Branch if Zero is Not Set, Relative, 2 Bytes, 2++ Cycles
373                 case 0xD0:
374                     {
375                         BranchOperation(!ZeroFlag);
376                         break;
377                     }
378                 // BPL Branch if Negative Clear, 2 Bytes, 2++ Cycles
379                 case 0x10:
380                     {
381                         BranchOperation(!NegativeFlag);
382                         break;
383                     }
384                 // BVC Branch if Overflow Clear, 2 Bytes, 2++ Cycles
385                 case 0x50:
386                     {
387                         BranchOperation(!OverflowFlag);
388                         break;
389                     }
390                 // BVS Branch if Overflow Set, 2 Bytes, 2++ Cycles
391                 case 0x70:
392                     {
393                         BranchOperation(OverflowFlag);
394                         break;
395                     }
396                 #endregion
397 
398                 #region BitWise Comparison Operations
399                 //AND Compare Memory with Accumulator, Immediate, 2 Bytes, 2 Cycles
400                 case 0x29:
401                     {
402                         AndOperation(AddressingMode\&.Immediate);
403                         break;
404                     }
405                 //AND Compare Memory with Accumulator, Zero Page, 2 Bytes, 3 Cycles
406                 case 0x25:
407                     {
408                         AndOperation(AddressingMode\&.ZeroPage);
409                         break;
410                     }
411                 //AND Compare Memory with Accumulator, Zero PageX, 2 Bytes, 3 Cycles
412                 case 0x35:
413                     {
414                         AndOperation(AddressingMode\&.ZeroPageX);
415                         break;
416                     }
417                 //AND Compare Memory with Accumulator, Absolute,  3 Bytes, 4 Cycles
418                 case 0x2D:
419                     {
420                         AndOperation(AddressingMode\&.Absolute);
421                         break;
422                     }
423                 //AND Compare Memory with Accumulator, AbsolueteX 3 Bytes, 4+ Cycles
424                 case 0x3D:
425                     {
426                         AndOperation(AddressingMode\&.AbsoluteX);
427                         break;
428                     }
429                 //AND Compare Memory with Accumulator, AbsoluteY, 3 Bytes, 4+ Cycles
430                 case 0x39:
431                     {
432                         AndOperation(AddressingMode\&.AbsoluteY);
433                         break;
434                     }
435                 //AND Compare Memory with Accumulator, IndexedIndirect, 2 Bytes, 6 Cycles
436                 case 0x21:
437                     {
438                         AndOperation(AddressingMode\&.IndirectX);
439                         break;
440                     }
441                 //AND Compare Memory with Accumulator, IndirectIndexed, 2 Bytes, 5 Cycles
442                 case 0x31:
443                     {
444                         AndOperation(AddressingMode\&.IndirectY);
445                         break;
446                     }
447                 //BIT Compare Memory with Accumulator, Zero Page, 2 Bytes, 3 Cycles
448                 case 0x24:
449                     {
450                         BitOperation(AddressingMode\&.ZeroPage);
451                         break;
452                     }
453                 //BIT Compare Memory with Accumulator, Absolute, 2 Bytes, 4 Cycles
454                 case 0x2C:
455                     {
456                         BitOperation(AddressingMode\&.Absolute);
457                         break;
458                     }
459                 //EOR Exclusive OR Memory with Accumulator, Immediate, 2 Bytes, 2 Cycles
460                 case 0x49:
461                     {
462                         EorOperation(AddressingMode\&.Immediate);
463                         break;
464                     }
465                 //EOR Exclusive OR Memory with Accumulator, Zero Page, 2 Bytes, 3 Cycles
466                 case 0x45:
467                     {
468                         EorOperation(AddressingMode\&.ZeroPage);
469                         break;
470                     }
471                 //EOR Exclusive OR Memory with Accumulator, Zero Page X, 2 Bytes, 4 Cycles
472                 case 0x55:
473                     {
474                         EorOperation(AddressingMode\&.ZeroPageX);
475                         break;
476                     }
477                 //EOR Exclusive OR Memory with Accumulator, Absolute, 3 Bytes, 4 Cycles
478                 case 0x4D:
479                     {
480                         EorOperation(AddressingMode\&.Absolute);
481                         break;
482                     }
483                 //EOR Exclusive OR Memory with Accumulator, Absolute X, 3 Bytes, 4+ Cycles
484                 case 0x5D:
485                     {
486                         EorOperation(AddressingMode\&.AbsoluteX);
487                         break;
488                     }
489                 //EOR Exclusive OR Memory with Accumulator, Absolute Y, 3 Bytes, 4+ Cycles
490                 case 0x59:
491                     {
492                         EorOperation(AddressingMode\&.AbsoluteY);
493                         break;
494                     }
495                 //EOR Exclusive OR Memory with Accumulator, IndexedIndirect, 2 Bytes 6 Cycles
496                 case 0x41:
497                     {
498                         EorOperation(AddressingMode\&.IndirectX);
499                         break;
500                     }
501                 //EOR Exclusive OR Memory with Accumulator, IndirectIndexed, 2 Bytes 5 Cycles
502                 case 0x51:
503                     {
504                         EorOperation(AddressingMode\&.IndirectY);
505                         break;
506                     }
507                 //ORA Compare Memory with Accumulator, Immediate, 2 Bytes, 2 Cycles
508                 case 0x09:
509                     {
510                         OrOperation(AddressingMode\&.Immediate);
511                         break;
512                     }
513                 //ORA Compare Memory with Accumulator, Zero Page, 2 Bytes, 2 Cycles
514                 case 0x05:
515                     {
516                         OrOperation(AddressingMode\&.ZeroPage);
517                         break;
518                     }
519                 //ORA Compare Memory with Accumulator, Zero PageX, 2 Bytes, 4 Cycles
520                 case 0x15:
521                     {
522                         OrOperation(AddressingMode\&.ZeroPageX);
523                         break;
524                     }
525                 //ORA Compare Memory with Accumulator, Absolute,  3 Bytes, 4 Cycles
526                 case 0x0D:
527                     {
528                         OrOperation(AddressingMode\&.Absolute);
529                         break;
530                     }
531                 //ORA Compare Memory with Accumulator, AbsolueteX 3 Bytes, 4+ Cycles
532                 case 0x1D:
533                     {
534                         OrOperation(AddressingMode\&.AbsoluteX);
535                         break;
536                     }
537                 //ORA Compare Memory with Accumulator, AbsoluteY, 3 Bytes, 4+ Cycles
538                 case 0x19:
539                     {
540                         OrOperation(AddressingMode\&.AbsoluteY);
541                         break;
542                     }
543                 //ORA Compare Memory with Accumulator, IndexedIndirect, 2 Bytes, 6 Cycles
544                 case 0x01:
545                     {
546                         OrOperation(AddressingMode\&.IndirectX);
547                         break;
548                     }
549                 //ORA Compare Memory with Accumulator, IndirectIndexed, 2 Bytes, 5 Cycles
550                 case 0x11:
551                     {
552                         OrOperation(AddressingMode\&.IndirectY);
553                         break;
554                     }
555                 #endregion
556 
557                 #region Clear Flag Operations
558                 //CLC Clear Carry Flag, Implied, 1 Byte, 2 Cycles
559                 case 0x18:
560                     {
561                         CarryFlag = false;
562                         IncrementCycleCount();
563                         break;
564                     }
565                 //CLD Clear Decimal Flag, Implied, 1 Byte, 2 Cycles
566                 case 0xD8:
567                     {
568                         DecimalFlag = false;
569                         IncrementCycleCount();
570                         break;
571 
572                     }
573                 //CLI Clear Interrupt Flag, Implied, 1 Byte, 2 Cycles
574                 case 0x58:
575                     {
576                         DisableInterruptFlag = false;
577                         IncrementCycleCount();
578                         break;
579 
580                     }
581                 //CLV Clear Overflow Flag, Implied, 1 Byte, 2 Cycles
582                 case 0xB8:
583                     {
584                         OverflowFlag = false;
585                         IncrementCycleCount();
586                         break;
587                     }
588 
589                 #endregion
590 
591                 #region Compare Operations
592                 //CMP Compare Accumulator with Memory, Immediate, 2 Bytes, 2 Cycles
593                 case 0xC9:
594                     {
595                         CompareOperation(AddressingMode\&.Immediate, Accumulator);
596                         break;
597                     }
598                 //CMP Compare Accumulator with Memory, Zero Page, 2 Bytes, 3 Cycles
599                 case 0xC5:
600                     {
601                         CompareOperation(AddressingMode\&.ZeroPage, Accumulator);
602                         break;
603                     }
604                 //CMP Compare Accumulator with Memory, Zero Page x, 2 Bytes, 4 Cycles
605                 case 0xD5:
606                     {
607                         CompareOperation(AddressingMode\&.ZeroPageX, Accumulator);
608                         break;
609                     }
610                 //CMP Compare Accumulator with Memory, Absolute, 3 Bytes, 4 Cycles
611                 case 0xCD:
612                     {
613                         CompareOperation(AddressingMode\&.Absolute, Accumulator);
614                         break;
615                     }
616                 //CMP Compare Accumulator with Memory, Absolute X, 2 Bytes, 4 Cycles
617                 case 0xDD:
618                     {
619                         CompareOperation(AddressingMode\&.AbsoluteX, Accumulator);
620                         break;
621                     }
622                 //CMP Compare Accumulator with Memory, Absolute Y, 2 Bytes, 4 Cycles
623                 case 0xD9:
624                     {
625                         CompareOperation(AddressingMode\&.AbsoluteY, Accumulator);
626                         break;
627                     }
628                 //CMP Compare Accumulator with Memory, Indirect X, 2 Bytes, 6 Cycles
629                 case 0xC1:
630                     {
631                         CompareOperation(AddressingMode\&.IndirectX, Accumulator);
632                         break;
633                     }
634                 //CMP Compare Accumulator with Memory, Indirect Y, 2 Bytes, 5 Cycles
635                 case 0xD1:
636                     {
637                         CompareOperation(AddressingMode\&.IndirectY, Accumulator);
638                         break;
639                     }
640                 //CPX Compare Accumulator with X Register, Immediate, 2 Bytes, 2 Cycles
641                 case 0xE0:
642                     {
643                         CompareOperation(AddressingMode\&.Immediate, XRegister);
644                         break;
645                     }
646                 //CPX Compare Accumulator with X Register, Zero Page, 2 Bytes, 3 Cycles
647                 case 0xE4:
648                     {
649                         CompareOperation(AddressingMode\&.ZeroPage, XRegister);
650                         break;
651                     }
652                 //CPX Compare Accumulator with X Register, Absolute, 3 Bytes, 4 Cycles
653                 case 0xEC:
654                     {
655                         CompareOperation(AddressingMode\&.Absolute, XRegister);
656                         break;
657                     }
658                 //CPY Compare Accumulator with Y Register, Immediate, 2 Bytes, 2 Cycles
659                 case 0xC0:
660                     {
661                         CompareOperation(AddressingMode\&.Immediate, YRegister);
662                         break;
663                     }
664                 //CPY Compare Accumulator with Y Register, Zero Page, 2 Bytes, 3 Cycles
665                 case 0xC4:
666                     {
667                         CompareOperation(AddressingMode\&.ZeroPage, YRegister);
668                         break;
669                     }
670                 //CPY Compare Accumulator with Y Register, Absolute, 3 Bytes, 4 Cycles
671                 case 0xCC:
672                     {
673                         CompareOperation(AddressingMode\&.Absolute, YRegister);
674                         break;
675                     }
676                 #endregion
677 
678                 #region Increment/Decrement Operations
679                 //DEC Decrement Memory by One, Zero Page, 2 Bytes, 5 Cycles
680                 case 0xC6:
681                     {
682                         ChangeMemoryByOne(AddressingMode\&.ZeroPage, true);
683                         break;
684                     }
685                 //DEC Decrement Memory by One, Zero Page X, 2 Bytes, 6 Cycles
686                 case 0xD6:
687                     {
688                         ChangeMemoryByOne(AddressingMode\&.ZeroPageX, true);
689                         break;
690                     }
691                 //DEC Decrement Memory by One, Absolute, 3 Bytes, 6 Cycles
692                 case 0xCE:
693                     {
694                         ChangeMemoryByOne(AddressingMode\&.Absolute, true);
695                         break;
696                     }
697                 //DEC Decrement Memory by One, Absolute X, 3 Bytes, 7 Cycles
698                 case 0xDE:
699                     {
700                         ChangeMemoryByOne(AddressingMode\&.AbsoluteX, true);
701                         IncrementCycleCount();
702                         break;
703                     }
704                 //DEX Decrement X Register by One, Implied, 1 Bytes, 2 Cycles
705                 case 0xCA:
706                     {
707                         ChangeRegisterByOne(true, true);
708                         break;
709                     }
710                 //DEY Decrement Y Register by One, Implied, 1 Bytes, 2 Cycles
711                 case 0x88:
712                     {
713                         ChangeRegisterByOne(false, true);
714                         break;
715                     }
716                 //INC Increment Memory by One, Zero Page, 2 Bytes, 5 Cycles
717                 case 0xE6:
718                     {
719                         ChangeMemoryByOne(AddressingMode\&.ZeroPage, false);
720                         break;
721                     }
722                 //INC Increment Memory by One, Zero Page X, 2 Bytes, 6 Cycles
723                 case 0xF6:
724                     {
725                         ChangeMemoryByOne(AddressingMode\&.ZeroPageX, false);
726                         break;
727                     }
728                 //INC Increment Memory by One, Absolute, 3 Bytes, 6 Cycles
729                 case 0xEE:
730                     {
731                         ChangeMemoryByOne(AddressingMode\&.Absolute, false);
732                         break;
733                     }
734                 //INC Increment Memory by One, Absolute X, 3 Bytes, 7 Cycles
735                 case 0xFE:
736                     {
737                         ChangeMemoryByOne(AddressingMode\&.AbsoluteX, false);
738                         IncrementCycleCount();
739                         break;
740                     }
741                 //INX Increment X Register by One, Implied, 1 Bytes, 2 Cycles
742                 case 0xE8:
743                     {
744                         ChangeRegisterByOne(true, false);
745                         break;
746                     }
747                 //INY Increment Y Register by One, Implied, 1 Bytes, 2 Cycles
748                 case 0xC8:
749                     {
750                         ChangeRegisterByOne(false, false);
751                         break;
752                     }
753                 #endregion
754 
755                 #region GOTO and GOSUB Operations
756                 //JMP Jump to New Location, Absolute 3 Bytes, 3 Cycles
757                 case 0x4C:
758                     {
759                         ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
760                         break;
761                     }
762                 //JMP Jump to New Location, Indirect 3 Bytes, 5 Cycles
763                 case 0x6C:
764                     {
765                         ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
766 
767                         if ((ProgramCounter & 0xFF) == 0xFF)
768                         {
769                             //Get the first half of the address
770                             int address = MemoryMap\&.Read(ProgramCounter);
771 
772                             //Get the second half of the address, due to the issue with page boundary it reads from the wrong location!
773                             address += 256 * MemoryMap\&.Read(ProgramCounter - 255);
774                             ProgramCounter = address;
775                         }
776                         else
777                         {
778                             ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
779                         }
780 
781                         break;
782                     }
783                 //JSR Jump to SubRoutine, Absolute, 3 Bytes, 6 Cycles
784                 case 0x20:
785                     {
786                         JumpToSubRoutineOperation();
787                         break;
788                     }
789                 //BRK Simulate IRQ, Implied, 1 Byte, 7 Cycles
790                 case 0x00:
791                     {
792                         BreakOperation(true, 0xFFFE);
793                         break;
794                     }
795                 //RTI Return From Interrupt, Implied, 1 Byte, 6 Cycles
796                 case 0x40:
797                     {
798                         ReturnFromInterruptOperation();
799                         break;
800                     }
801                 //RTS Return From Subroutine, Implied, 1 Byte, 6 Cycles
802                 case 0x60:
803                     {
804                         ReturnFromSubRoutineOperation();
805                         break;
806                     }
807                 #endregion
808 
809                 #region Load Value From Memory Operations
810                 //LDA Load Accumulator with Memory, Immediate, 2 Bytes, 2 Cycles
811                 case 0xA9:
812                     {
813                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Immediate));
814                         SetZeroFlag(Accumulator);
815                         SetNegativeFlag(Accumulator);
816                         break;
817                     }
818                 //LDA Load Accumulator with Memory, Zero Page, 2 Bytes, 3 Cycles
819                 case 0xA5:
820                     {
821                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPage));
822                         SetZeroFlag(Accumulator);
823                         SetNegativeFlag(Accumulator);
824                         break;
825                     }
826                 //LDA Load Accumulator with Memory, Zero Page X, 2 Bytes, 4 Cycles
827                 case 0xB5:
828                     {
829                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX));
830                         SetZeroFlag(Accumulator);
831                         SetNegativeFlag(Accumulator);
832                         break;
833                     }
834                 //LDA Load Accumulator with Memory, Absolute, 3 Bytes, 4 Cycles
835                 case 0xAD:
836                     {
837                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Absolute));
838                         SetZeroFlag(Accumulator);
839                         SetNegativeFlag(Accumulator);
840                         break;
841                     }
842                 //LDA Load Accumulator with Memory, Absolute X, 3 Bytes, 4+ Cycles
843                 case 0xBD:
844                     {
845                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteX));
846                         SetZeroFlag(Accumulator);
847                         SetNegativeFlag(Accumulator);
848                         break;
849                     }
850                 //LDA Load Accumulator with Memory, Absolute Y, 3 Bytes, 4+ Cycles
851                 case 0xB9:
852                     {
853                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteY));
854                         SetZeroFlag(Accumulator);
855                         SetNegativeFlag(Accumulator);
856                         break;
857                     }
858                 //LDA Load Accumulator with Memory, Index Indirect, 2 Bytes, 6 Cycles
859                 case 0xA1:
860                     {
861                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.IndirectX));
862                         SetZeroFlag(Accumulator);
863                         SetNegativeFlag(Accumulator);
864                         break;
865                     }
866                 //LDA Load Accumulator with Memory, Indirect Index, 2 Bytes, 5+ Cycles
867                 case 0xB1:
868                     {
869                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.IndirectY));
870                         SetZeroFlag(Accumulator);
871                         SetNegativeFlag(Accumulator);
872                         break;
873                     }
874                 //LDX Load X with memory, Immediate, 2 Bytes, 2 Cycles
875                 case 0xA2:
876                     {
877                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Immediate));
878                         SetZeroFlag(XRegister);
879                         SetNegativeFlag(XRegister);
880                         break;
881                     }
882                 //LDX Load X with memory, Zero Page, 2 Bytes, 3 Cycles
883                 case 0xA6:
884                     {
885                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPage));
886                         SetZeroFlag(XRegister);
887                         SetNegativeFlag(XRegister);
888                         break;
889                     }
890                 //LDX Load X with memory, Zero Page Y, 2 Bytes, 4 Cycles
891                 case 0xB6:
892                     {
893                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPageY));
894                         SetZeroFlag(XRegister);
895                         SetNegativeFlag(XRegister);
896                         break;
897                     }
898                 //LDX Load X with memory, Absolute, 3 Bytes, 4 Cycles
899                 case 0xAE:
900                     {
901                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Absolute));
902                         SetZeroFlag(XRegister);
903                         SetNegativeFlag(XRegister);
904                         break;
905                     }
906                 //LDX Load X with memory, Absolute Y, 3 Bytes, 4+ Cycles
907                 case 0xBE:
908                     {
909                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteY));
910                         SetZeroFlag(XRegister);
911                         SetNegativeFlag(XRegister);
912                         break;
913                     }
914                 //LDY Load Y with memory, Immediate, 2 Bytes, 2 Cycles
915                 case 0xA0:
916                     {
917                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Immediate));
918                         SetZeroFlag(YRegister);
919                         SetNegativeFlag(YRegister);
920                         break;
921                     }
922                 //LDY Load Y with memory, Zero Page, 2 Bytes, 3 Cycles
923                 case 0xA4:
924                     {
925                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPage));
926                         SetZeroFlag(YRegister);
927                         SetNegativeFlag(YRegister);
928                         break;
929                     }
930                 //LDY Load Y with memory, Zero Page X, 2 Bytes, 4 Cycles
931                 case 0xB4:
932                     {
933                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX));
934                         SetZeroFlag(YRegister);
935                         SetNegativeFlag(YRegister);
936                         break;
937                     }
938                 //LDY Load Y with memory, Absolute, 3 Bytes, 4 Cycles
939                 case 0xAC:
940                     {
941                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Absolute));
942                         SetZeroFlag(YRegister);
943                         SetNegativeFlag(YRegister);
944                         break;
945                     }
946                 //LDY Load Y with memory, Absolue X, 3 Bytes, 4+ Cycles
947                 case 0xBC:
948                     {
949                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteX));
950                         SetZeroFlag(YRegister);
951                         SetNegativeFlag(YRegister);
952                         break;
953                     }
954                 #endregion
955 
956                 #region Push/Pull Stack
957                 //PHA Push Accumulator onto Stack, Implied, 1 Byte, 3 Cycles
958                 case 0x48:
959                     {
960                         MemoryMap\&.Read(ProgramCounter + 1);
961 
962                         PokeStack((byte)Accumulator);
963                         StackPointer--;
964                         IncrementCycleCount();
965                         break;
966 
967                     }
968                 //PHP Push Flags onto Stack, Implied, 1 Byte, 3 Cycles
969                 case 0x08:
970                     {
971                         MemoryMap\&.Read(ProgramCounter + 1);
972 
973                         PushFlagsOperation();
974                         StackPointer--;
975                         IncrementCycleCount();
976                         break;
977                     }
978                 //PLA Pull Accumulator from Stack, Implied, 1 Byte, 4 Cycles
979                 case 0x68:
980                     {
981                         MemoryMap\&.Read(ProgramCounter + 1);
982                         StackPointer++;
983                         IncrementCycleCount();
984 
985                         Accumulator = PeekStack();
986                         SetNegativeFlag(Accumulator);
987                         SetZeroFlag(Accumulator);
988 
989                         IncrementCycleCount();
990                         break;
991                     }
992                 //PLP Pull Flags from Stack, Implied, 1 Byte, 4 Cycles
993                 case 0x28:
994                     {
995                         MemoryMap\&.Read(ProgramCounter + 1);
996 
997                         StackPointer++;
998                         IncrementCycleCount();
999 
1000                         PullFlagsOperation();
1001 
1002                         IncrementCycleCount();
1003                         break;
1004                     }
1005                 //TSX Transfer Stack Pointer to X Register, 1 Bytes, 2 Cycles
1006                 case 0xBA:
1007                     {
1008                         XRegister = StackPointer;
1009 
1010                         SetNegativeFlag(XRegister);
1011                         SetZeroFlag(XRegister);
1012                         IncrementCycleCount();
1013                         break;
1014                     }
1015                 //TXS Transfer X Register to Stack Pointer, 1 Bytes, 2 Cycles
1016                 case 0x9A:
1017                     {
1018                         StackPointer = (byte)XRegister;
1019                         IncrementCycleCount();
1020                         break;
1021                     }
1022                 #endregion
1023 
1024                 #region Set Flag Operations
1025                 //SEC Set Carry, Implied, 1 Bytes, 2 Cycles
1026                 case 0x38:
1027                     {
1028                         CarryFlag = true;
1029                         IncrementCycleCount();
1030                         break;
1031                     }
1032                 //SED Set Interrupt, Implied, 1 Bytes, 2 Cycles
1033                 case 0xF8:
1034                     {
1035                         DecimalFlag = true;
1036                         IncrementCycleCount();
1037                         break;
1038                     }
1039                 //SEI Set Interrupt, Implied, 1 Bytes, 2 Cycles
1040                 case 0x78:
1041                     {
1042                         DisableInterruptFlag = true;
1043                         IncrementCycleCount();
1044                         break;
1045                     }
1046                 #endregion
1047 
1048                 #region Shift/Rotate Operations
1049                 //ASL Shift Left 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1050                 case 0x0A:
1051                     {
1052                         AslOperation(AddressingMode\&.Accumulator);
1053                         break;
1054                     }
1055                 //ASL Shift Left 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1056                 case 0x06:
1057                     {
1058                         AslOperation(AddressingMode\&.ZeroPage);
1059                         break;
1060                     }
1061                 //ASL Shift Left 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1062                 case 0x16:
1063                     {
1064                         AslOperation(AddressingMode\&.ZeroPageX);
1065                         break;
1066                     }
1067                 //ASL Shift Left 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1068                 case 0x0E:
1069                     {
1070                         AslOperation(AddressingMode\&.Absolute);
1071                         break;
1072                     }
1073                 //ASL Shift Left 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1074                 case 0x1E:
1075                     {
1076                         AslOperation(AddressingMode\&.AbsoluteX);
1077                         IncrementCycleCount();
1078                         break;
1079                     }
1080                 //LSR Shift Left 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1081                 case 0x4A:
1082                     {
1083                         LsrOperation(AddressingMode\&.Accumulator);
1084                         break;
1085                     }
1086                 //LSR Shift Left 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1087                 case 0x46:
1088                     {
1089                         LsrOperation(AddressingMode\&.ZeroPage);
1090                         break;
1091                     }
1092                 //LSR Shift Left 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1093                 case 0x56:
1094                     {
1095                         LsrOperation(AddressingMode\&.ZeroPageX);
1096                         break;
1097                     }
1098                 //LSR Shift Left 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1099                 case 0x4E:
1100                     {
1101                         LsrOperation(AddressingMode\&.Absolute);
1102                         break;
1103                     }
1104                 //LSR Shift Left 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1105                 case 0x5E:
1106                     {
1107                         LsrOperation(AddressingMode\&.AbsoluteX);
1108                         IncrementCycleCount();
1109                         break;
1110                     }
1111                 //ROL Rotate Left 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1112                 case 0x2A:
1113                     {
1114                         RolOperation(AddressingMode\&.Accumulator);
1115                         break;
1116                     }
1117                 //ROL Rotate Left 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1118                 case 0x26:
1119                     {
1120                         RolOperation(AddressingMode\&.ZeroPage);
1121                         break;
1122                     }
1123                 //ROL Rotate Left 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1124                 case 0x36:
1125                     {
1126                         RolOperation(AddressingMode\&.ZeroPageX);
1127                         break;
1128                     }
1129                 //ROL Rotate Left 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1130                 case 0x2E:
1131                     {
1132                         RolOperation(AddressingMode\&.Absolute);
1133                         break;
1134                     }
1135                 //ROL Rotate Left 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1136                 case 0x3E:
1137                     {
1138                         RolOperation(AddressingMode\&.AbsoluteX);
1139                         IncrementCycleCount();
1140                         break;
1141                     }
1142                 //ROR Rotate Right 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1143                 case 0x6A:
1144                     {
1145                         RorOperation(AddressingMode\&.Accumulator);
1146                         break;
1147                     }
1148                 //ROR Rotate Right 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1149                 case 0x66:
1150                     {
1151                         RorOperation(AddressingMode\&.ZeroPage);
1152                         break;
1153                     }
1154                 //ROR Rotate Right 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1155                 case 0x76:
1156                     {
1157                         RorOperation(AddressingMode\&.ZeroPageX);
1158                         break;
1159                     }
1160                 //ROR Rotate Right 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1161                 case 0x6E:
1162                     {
1163                         RorOperation(AddressingMode\&.Absolute);
1164                         break;
1165                     }
1166                 //ROR Rotate Right 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1167                 case 0x7E:
1168                     {
1169                         RorOperation(AddressingMode\&.AbsoluteX);
1170                         IncrementCycleCount();
1171                         break;
1172                     }
1173                 #endregion
1174 
1175                 #region Store Value In Memory Operations
1176                 //STA Store Accumulator In Memory, Zero Page, 2 Bytes, 3 Cycles
1177                 case 0x85:
1178                     {
1179                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPage), (byte)Accumulator);
1180                         break;
1181                     }
1182                 //STA Store Accumulator In Memory, Zero Page X, 2 Bytes, 4 Cycles
1183                 case 0x95:
1184                     {
1185                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX), (byte)Accumulator);
1186                         break;
1187                     }
1188                 //STA Store Accumulator In Memory, Absolute, 3 Bytes, 4 Cycles
1189                 case 0x8D:
1190                     {
1191                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.Absolute), (byte)Accumulator);
1192                         break;
1193                     }
1194                 //STA Store Accumulator In Memory, Absolute X, 3 Bytes, 5 Cycles
1195                 case 0x9D:
1196                     {
1197                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.AbsoluteX), (byte)Accumulator);
1198                         IncrementCycleCount();
1199                         break;
1200                     }
1201                 //STA Store Accumulator In Memory, Absolute Y, 3 Bytes, 5 Cycles
1202                 case 0x99:
1203                     {
1204                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.AbsoluteY), (byte)Accumulator);
1205                         IncrementCycleCount();
1206                         break;
1207                     }
1208                 //STA Store Accumulator In Memory, Indexed Indirect, 2 Bytes, 6 Cycles
1209                 case 0x81:
1210                     {
1211                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.IndirectX), (byte)Accumulator);
1212                         break;
1213                     }
1214                 //STA Store Accumulator In Memory, Indirect Indexed, 2 Bytes, 6 Cycles
1215                 case 0x91:
1216                     {
1217                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.IndirectY), (byte)Accumulator);
1218                         IncrementCycleCount();
1219                         break;
1220                     }
1221                 //STX Store Index X, Zero Page, 2 Bytes, 3 Cycles
1222                 case 0x86:
1223                     {
1224                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPage), (byte)XRegister);
1225                         break;
1226                     }
1227                 //STX Store Index X, Zero Page Y, 2 Bytes, 4 Cycles
1228                 case 0x96:
1229                     {
1230                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPageY), (byte)XRegister);
1231                         break;
1232                     }
1233                 //STX Store Index X, Absolute, 3 Bytes, 4 Cycles
1234                 case 0x8E:
1235                     {
1236                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.Absolute), (byte)XRegister);
1237                         break;
1238                     }
1239                 //STY Store Index Y, Zero Page, 2 Bytes, 3 Cycles
1240                 case 0x84:
1241                     {
1242                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPage), (byte)YRegister);
1243                         break;
1244                     }
1245                 //STY Store Index Y, Zero Page X, 2 Bytes, 4 Cycles
1246                 case 0x94:
1247                     {
1248                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX), (byte)YRegister);
1249                         break;
1250                     }
1251                 //STY Store Index Y, Absolute, 2 Bytes, 4 Cycles
1252                 case 0x8C:
1253                     {
1254                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.Absolute), (byte)YRegister);
1255                         break;
1256                     }
1257                 #endregion
1258 
1259                 #region Transfer Operations
1260                 //TAX Transfer Accumulator to X Register, Implied, 1 Bytes, 2 Cycles
1261                 case 0xAA:
1262                     {
1263                         IncrementCycleCount();
1264                         XRegister = Accumulator;
1265 
1266                         SetNegativeFlag(XRegister);
1267                         SetZeroFlag(XRegister);
1268                         break;
1269                     }
1270                 //TAY Transfer Accumulator to Y Register, 1 Bytes, 2 Cycles
1271                 case 0xA8:
1272                     {
1273                         IncrementCycleCount();
1274                         YRegister = Accumulator;
1275 
1276                         SetNegativeFlag(YRegister);
1277                         SetZeroFlag(YRegister);
1278                         break;
1279                     }
1280                 //TXA Transfer X Register to Accumulator, Implied, 1 Bytes, 2 Cycles
1281                 case 0x8A:
1282                     {
1283                         IncrementCycleCount();
1284                         Accumulator = XRegister;
1285 
1286                         SetNegativeFlag(Accumulator);
1287                         SetZeroFlag(Accumulator);
1288                         break;
1289                     }
1290                 //TYA Transfer Y Register to Accumulator, Implied, 1 Bytes, 2 Cycles
1291                 case 0x98:
1292                     {
1293                         IncrementCycleCount();
1294                         Accumulator = YRegister;
1295 
1296                         SetNegativeFlag(Accumulator);
1297                         SetZeroFlag(Accumulator);
1298                         break;
1299                     }
1300                 #endregion
1301 
1302                 //NOP Operation, Implied, 1 Byte, 2 Cycles
1303                 case 0xEA:
1304                     {
1305                         IncrementCycleCount();
1306                         break;
1307                     }
1308 
1309                 default:
1310                     throw new NotSupportedException(string\&.Format("The OpCode {0} is not supported", CurrentOpCode));
1311             }
1312         }
.fi
.SS "int Hardware\&.W65C02\&.GetAddressByAddressingMode (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [protected]\fP"

.PP
Uses the AddressingMode to return the correct address based on the mode\&. Note: This method will not increment the program counter for any mode\&. Note: This method will return an error if called for either the immediate or accumulator modes\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing Mode to use
.RE
.PP
\fBReturns\fP
.RS 4
The memory Location
.RE
.PP

.PP
Definition at line \fB1340\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1341         {
1342             int address;
1343             int highByte;
1344             switch (addressingMode)
1345             {
1346                 case (AddressingMode\&.Absolute):
1347                     {
1348                         return (MemoryMap\&.Read(ProgramCounter++) | (MemoryMap\&.Read(ProgramCounter++) << 8));
1349                     }
1350                 case AddressingMode\&.AbsoluteX:
1351                     {
1352                         //Get the low half of the address
1353                         address = MemoryMap\&.Read(ProgramCounter++);
1354 
1355                         //Get the high byte
1356                         highByte = MemoryMap\&.Read(ProgramCounter++);
1357 
1358                         //We crossed a page boundry, so an extra read has occurred\&.
1359                         //However, if this is an ASL, LSR, DEC, INC, ROR, ROL or STA operation, we do not decrease it by 1\&.
1360                         if (address + XRegister > 0xFF)
1361                         {
1362                             switch (CurrentOpCode)
1363                             {
1364                                 case 0x1E:
1365                                 case 0xDE:
1366                                 case 0xFE:
1367                                 case 0x5E:
1368                                 case 0x3E:
1369                                 case 0x7E:
1370                                 case 0x9D:
1371                                     {
1372                                         //This is a MemoryMap\&.Read Fetch Write Operation, so we don't make the extra read\&.
1373                                         return ((highByte << 8 | address) + XRegister) & 0xFFFF;
1374                                     }
1375                                 default:
1376                                     {
1377                                         MemoryMap\&.Read((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);
1378                                         break;
1379                                     }
1380                             }
1381                         }
1382 
1383                         return ((highByte << 8 | address) + XRegister) & 0xFFFF;
1384                     }
1385                 case AddressingMode\&.AbsoluteY:
1386                     {
1387                         //Get the low half of the address
1388                         address = MemoryMap\&.Read(ProgramCounter++);
1389 
1390                         //Get the high byte
1391                         highByte = MemoryMap\&.Read(ProgramCounter++);
1392 
1393                         //We crossed a page boundry, so decrease the number of cycles by 1 if the operation is not STA
1394                         if (address + YRegister > 0xFF && CurrentOpCode != 0x99)
1395                         {
1396                             MemoryMap\&.Read((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);
1397                         }
1398 
1399                         //Bitshift the high byte into place, AND with FFFF to handle wrapping\&.
1400                         return ((highByte << 8 | address) + YRegister) & 0xFFFF;
1401                     }
1402                 case AddressingMode\&.Immediate:
1403                     {
1404                         return ProgramCounter++;
1405                     }
1406                 case AddressingMode\&.IndirectX:
1407                     {
1408                         //Get the location of the address to retrieve
1409                         address = MemoryMap\&.Read(ProgramCounter++);
1410                         MemoryMap\&.Read(address);
1411 
1412                         address += XRegister;
1413 
1414                         //Now get the final Address\&. The is not a zero page address either\&.
1415                         var finalAddress = MemoryMap\&.Read((address & 0xFF)) | (MemoryMap\&.Read((address + 1) & 0xFF) << 8);
1416                         return finalAddress;
1417                     }
1418                 case AddressingMode\&.IndirectY:
1419                     {
1420                         address = MemoryMap\&.Read(ProgramCounter++);
1421 
1422                         var finalAddress = MemoryMap\&.Read(address) + (MemoryMap\&.Read((address + 1) & 0xFF) << 8);
1423 
1424                         if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)
1425                         {
1426                             MemoryMap\&.Read((finalAddress + YRegister - 0xFF) & 0xFFFF);
1427                         }
1428 
1429                         return (finalAddress + YRegister) & 0xFFFF;
1430                     }
1431                 case AddressingMode\&.Relative:
1432                     {
1433                         return ProgramCounter;
1434                     }
1435                 case (AddressingMode\&.ZeroPage):
1436                     {
1437                         address = MemoryMap\&.Read(ProgramCounter++);
1438                         return address;
1439                     }
1440                 case (AddressingMode\&.ZeroPageX):
1441                     {
1442                         address = MemoryMap\&.Read(ProgramCounter++);
1443                         MemoryMap\&.Read(address);
1444 
1445                         address += XRegister;
1446                         address &= 0xFF;
1447 
1448                         //This address wraps if its greater than 0xFF
1449                         if (address > 0xFF)
1450                         {
1451                             address -= 0x100;
1452                             return address;
1453                         }
1454 
1455                         return address;
1456                     }
1457                 case (AddressingMode\&.ZeroPageY):
1458                     {
1459                         address = MemoryMap\&.Read(ProgramCounter++);
1460                         MemoryMap\&.Read(address);
1461 
1462                         address += YRegister;
1463                         address &= 0xFF;
1464 
1465                         return address;
1466                     }
1467                 default:
1468                     throw new InvalidOperationException(string\&.Format("The Address Mode '{0}' does not require an address", addressingMode));
1469             }
1470         }
.fi
.SS "\fBAddressingMode\fP Hardware\&.W65C02\&.GetAddressingMode ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB1685\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1686         {
1687             switch (CurrentOpCode)
1688             {
1689                 case 0x0D:  //ORA
1690                 case 0x2D:  //AND
1691                 case 0x4D:  //EOR
1692                 case 0x6D:  //ADC
1693                 case 0x8D:  //STA
1694                 case 0xAD:  //LDA
1695                 case 0xCD:  //CMP
1696                 case 0xED:  //SBC
1697                 case 0x0E:  //ASL
1698                 case 0x2E:  //ROL
1699                 case 0x4E:  //LSR
1700                 case 0x6E:  //ROR
1701                 case 0x8E:  //SDX
1702                 case 0xAE:  //LDX
1703                 case 0xCE:  //DEC
1704                 case 0xEE:  //INC
1705                 case 0x2C:  //Bit
1706                 case 0x4C:  //JMP
1707                 case 0x8C:  //STY
1708                 case 0xAC:  //LDY
1709                 case 0xCC:  //CPY
1710                 case 0xEC:  //CPX
1711                 case 0x20:  //JSR
1712                     {
1713                         return AddressingMode\&.Absolute;
1714                     }
1715                 case 0x1D:  //ORA
1716                 case 0x3D:  //AND
1717                 case 0x5D:  //EOR
1718                 case 0x7D:  //ADC
1719                 case 0x9D:  //STA
1720                 case 0xBD:  //LDA
1721                 case 0xDD:  //CMP
1722                 case 0xFD:  //SBC
1723                 case 0xBC:  //LDY
1724                 case 0xFE:  //INC
1725                 case 0x1E:  //ASL
1726                 case 0x3E:  //ROL
1727                 case 0x5E:  //LSR
1728                 case 0x7E:  //ROR
1729                     {
1730                         return AddressingMode\&.AbsoluteX;
1731                     }
1732                 case 0x19:  //ORA
1733                 case 0x39:  //AND
1734                 case 0x59:  //EOR
1735                 case 0x79:  //ADC
1736                 case 0x99:  //STA
1737                 case 0xB9:  //LDA
1738                 case 0xD9:  //CMP
1739                 case 0xF9:  //SBC
1740                 case 0xBE:  //LDX
1741                     {
1742                         return AddressingMode\&.AbsoluteY;
1743                     }
1744                 case 0x0A:  //ASL
1745                 case 0x4A:  //LSR
1746                 case 0x2A:  //ROL
1747                 case 0x6A:  //ROR
1748                     {
1749                         return AddressingMode\&.Accumulator;
1750                     }
1751 
1752                 case 0x09:  //ORA
1753                 case 0x29:  //AND
1754                 case 0x49:  //EOR
1755                 case 0x69:  //ADC
1756                 case 0xA0:  //LDY
1757                 case 0xC0:  //CPY
1758                 case 0xE0:  //CMP
1759                 case 0xA2:  //LDX
1760                 case 0xA9:  //LDA
1761                 case 0xC9:  //CMP
1762                 case 0xE9:  //SBC
1763                     {
1764                         return AddressingMode\&.Immediate;
1765                     }
1766                 case 0x00:  //BRK
1767                 case 0x18:  //CLC
1768                 case 0xD8:  //CLD
1769                 case 0x58:  //CLI
1770                 case 0xB8:  //CLV
1771                 case 0xDE:  //DEC
1772                 case 0xCA:  //DEX
1773                 case 0x88:  //DEY
1774                 case 0xE8:  //INX
1775                 case 0xC8:  //INY
1776                 case 0xEA:  //NOP
1777                 case 0x48:  //PHA
1778                 case 0x08:  //PHP
1779                 case 0x68:  //PLA
1780                 case 0x28:  //PLP
1781                 case 0x40:  //RTI
1782                 case 0x60:  //RTS
1783                 case 0x38:  //SEC
1784                 case 0xF8:  //SED
1785                 case 0x78:  //SEI
1786                 case 0xAA:  //TAX
1787                 case 0xA8:  //TAY
1788                 case 0xBA:  //TSX
1789                 case 0x8A:  //TXA
1790                 case 0x9A:  //TXS
1791                 case 0x98:  //TYA
1792                     {
1793                         return AddressingMode\&.Implied;
1794                     }
1795                 case 0x6C:
1796                     {
1797                         return AddressingMode\&.Indirect;
1798                     }
1799 
1800                 case 0x61:  //ADC
1801                 case 0x21:  //AND
1802                 case 0xC1:  //CMP
1803                 case 0x41:  //EOR
1804                 case 0xA1:  //LDA
1805                 case 0x01:  //ORA
1806                 case 0xE1:  //SBC
1807                 case 0x81:  //STA
1808                     {
1809                         return AddressingMode\&.IndirectX;
1810                     }
1811                 case 0x71:  //ADC
1812                 case 0x31:  //AND
1813                 case 0xD1:  //CMP
1814                 case 0x51:  //EOR
1815                 case 0xB1:  //LDA
1816                 case 0x11:  //ORA
1817                 case 0xF1:  //SBC
1818                 case 0x91:  //STA
1819                     {
1820                         return AddressingMode\&.IndirectY;
1821                     }
1822                 case 0x90:  //BCC
1823                 case 0xB0:  //BCS
1824                 case 0xF0:  //BEQ
1825                 case 0x30:  //BMI
1826                 case 0xD0:  //BNE
1827                 case 0x10:  //BPL
1828                 case 0x50:  //BVC
1829                 case 0x70:  //BVS
1830                     {
1831                         return AddressingMode\&.Relative;
1832                     }
1833                 case 0x65:  //ADC
1834                 case 0x25:  //AND
1835                 case 0x06:  //ASL
1836                 case 0x24:  //BIT
1837                 case 0xC5:  //CMP
1838                 case 0xE4:  //CPX
1839                 case 0xC4:  //CPY
1840                 case 0xC6:  //DEC
1841                 case 0x45:  //EOR
1842                 case 0xE6:  //INC
1843                 case 0xA5:  //LDA
1844                 case 0xA6:  //LDX
1845                 case 0xA4:  //LDY
1846                 case 0x46:  //LSR
1847                 case 0x05:  //ORA
1848                 case 0x26:  //ROL
1849                 case 0x66:  //ROR
1850                 case 0xE5:  //SBC
1851                 case 0x85:  //STA
1852                 case 0x86:  //STX
1853                 case 0x84:  //STY
1854                     {
1855                         return AddressingMode\&.ZeroPage;
1856                     }
1857                 case 0x75:  //ADC
1858                 case 0x35:  //AND
1859                 case 0x16:  //ASL
1860                 case 0xD5:  //CMP
1861                 case 0xD6:  //DEC
1862                 case 0x55:  //EOR
1863                 case 0xF6:  //INC
1864                 case 0xB5:  //LDA
1865                 case 0xB6:  //LDX
1866                 case 0xB4:  //LDY
1867                 case 0x56:  //LSR
1868                 case 0x15:  //ORA
1869                 case 0x36:  //ROL
1870                 case 0x76:  //ROR
1871                 case 0xF5:  //SBC
1872                 case 0x95:  //STA
1873                 case 0x96:  //STX
1874                 case 0x94:  //STY
1875                     {
1876                         return AddressingMode\&.ZeroPageX;
1877                     }
1878                 default:
1879                     throw new NotSupportedException(string\&.Format("Opcode {0} is not supported", CurrentOpCode));
1880             }
1881         }
.fi
.SS "int Hardware\&.W65C02\&.GetCycleCount ()\fC [inline]\fP"

.PP
Gets the Number of Cycles that have elapsed  
.PP
\fBReturns\fP
.RS 4
The number of elapsed cycles
.RE
.PP

.PP
Definition at line \fB209\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
210         {
211             return _cycleCount;
212         }
.fi
.SS "void Hardware\&.W65C02\&.IncrementCycleCount ()\fC [inline]\fP"

.PP
Increments the Cycle Count, causes a CycleCountIncrementedAction to fire\&.  
.PP
Definition at line \fB217\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
218         {
219             _cycleCount++;
220             CycleCountIncrementedAction();
221 
222             _previousInterrupt = _interrupt;
223             _interrupt = TriggerNmi || (TriggerIRQ && !DisableInterruptFlag);
224         }
.fi
.SS "void Hardware\&.W65C02\&.InterruptRequest ()\fC [inline]\fP"

.PP
The InterruptRequest or IRQ  
.PP
Definition at line \fB200\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
201         {
202             TriggerIRQ = true;
203         }
.fi
.SS "void Hardware\&.W65C02\&.JumpToSubRoutineOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The JSR routine\&. Jumps to a subroutine\&.  
.PP
Definition at line \fB2313\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2314         {
2315             IncrementCycleCount();
2316 
2317             //Put the high value on the stack, this should be the address after our operation -1
2318             //The RTS operation increments the PC by 1 which is why we don't move 2
2319             PokeStack((byte)(((ProgramCounter + 1) >> 8) & 0xFF));
2320             StackPointer--;
2321             IncrementCycleCount();
2322 
2323             PokeStack((byte)((ProgramCounter + 1) & 0xFF));
2324             StackPointer--;
2325             IncrementCycleCount();
2326 
2327             ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
2328         }
.fi
.SS "void Hardware\&.W65C02\&.LsrOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The LSR Operation\&. Performs a Left shift operation on a value in memory  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2108\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2109         {
2110             int value;
2111             var memoryAddress = 0;
2112             if (addressingMode == AddressingMode\&.Accumulator)
2113             {
2114                 MemoryMap\&.Read(ProgramCounter + 1);
2115                 value = Accumulator;
2116             }
2117             else
2118             {
2119                 memoryAddress = GetAddressByAddressingMode(addressingMode);
2120                 value = MemoryMap\&.Read(memoryAddress);
2121             }
2122 
2123             //Dummy Write
2124             if (addressingMode != AddressingMode\&.Accumulator)
2125             {
2126                 MemoryMap\&.Write(memoryAddress, (byte)value);
2127             }
2128 
2129             NegativeFlag = false;
2130 
2131             //If the Zero bit is set, we have a carry
2132             CarryFlag = (value & 0x01) != 0;
2133 
2134             value = (value >> 1);
2135 
2136             SetZeroFlag(value);
2137             if (addressingMode == AddressingMode\&.Accumulator)
2138                 Accumulator = value;
2139             else
2140             {
2141                 MemoryMap\&.Write(memoryAddress, (byte)value);
2142             }
2143         }
.fi
.SS "void Hardware\&.W65C02\&.MoveProgramCounterByRelativeValue (byte valueToMove)\fC [inline]\fP, \fC [private]\fP"

.PP
Moves the ProgramCounter in a given direction based on the value inputted 
.PP
Definition at line \fB1476\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1477         {
1478             var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;
1479 
1480             var newProgramCounter = ProgramCounter + movement;
1481 
1482             //This makes sure that we always land on the correct spot for a positive number
1483             if (movement >= 0)
1484                 newProgramCounter++;
1485 
1486             //We Crossed a Page Boundary\&. So we increment the cycle counter by one\&. The +1 is because we always check from the end of the instruction not the beginning
1487             if (((ProgramCounter + 1 ^ newProgramCounter) & 0xff00) != 0x0000)
1488             {
1489                 IncrementCycleCount();
1490             }
1491 
1492             ProgramCounter = newProgramCounter;
1493             MemoryMap\&.Read(ProgramCounter);
1494         }
.fi
.SS "void Hardware\&.W65C02\&.NextStep ()\fC [inline]\fP"

.PP
Performs the next step on the processor  
.PP
Definition at line \fB171\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
172         {
173             SetDisassembly();
174 
175             //Have to read this first otherwise it causes tests to fail on a NES
176             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
177 
178             ProgramCounter++;
179 
180             ExecuteOpCode();
181 
182             if (_previousInterrupt)
183             {
184                 if (TriggerNmi)
185                 {
186                     ProcessNMI();
187                     TriggerNmi = false;
188                 }
189                 else if (TriggerIRQ)
190                 {
191                     ProcessIRQ();
192                     TriggerIRQ = false;
193                 }
194             }
195         }
.fi
.SS "void Hardware\&.W65C02\&.OrOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The Or Operation\&. Performs an Or Operation with the accumulator and a value in memory  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2149\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2150         {
2151             Accumulator = Accumulator | MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2152 
2153             SetNegativeFlag(Accumulator);
2154             SetZeroFlag(Accumulator);
2155         }
.fi
.SS "byte Hardware\&.W65C02\&.PeekStack ()\fC [inline]\fP, \fC [private]\fP"

.PP
Returns a the value from the stack without changing the position of the stack pointer  
.PP
\fBReturns\fP
.RS 4
The value at the current Stack Pointer
.RE
.PP

.PP
Definition at line \fB1500\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1501         {
1502             //The stack lives at 0x100-0x1FF, but the value is only a byte so it needs to be translated
1503             return MemoryMap\&.Read(StackPointer + 0x100);
1504         }
.fi
.SS "void Hardware\&.W65C02\&.PokeStack (byte value)\fC [inline]\fP, \fC [private]\fP"

.PP
Write a value directly to the stack without modifying the Stack Pointer  
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The value to be written to the stack
.RE
.PP

.PP
Definition at line \fB1511\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1512         {
1513             //The stack lives at 0x100-0x1FF, but the value is only a byte so it needs to be translated
1514             MemoryMap\&.Write(StackPointer + 0x100, value);
1515         }
.fi
.SS "void Hardware\&.W65C02\&.ProcessIRQ ()\fC [inline]\fP, \fC [private]\fP"

.PP
This is ran anytime an IRQ occurrs  
.PP
Definition at line \fB2425\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2426         {
2427             if (DisableInterruptFlag)
2428                 return;
2429 
2430             ProgramCounter--;
2431             BreakOperation(false, 0xFFFE);
2432             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
2433 
2434             SetDisassembly();
2435         }
.fi
.SS "void Hardware\&.W65C02\&.ProcessNMI ()\fC [inline]\fP, \fC [private]\fP"

.PP
This is ran anytime an NMI occurrs  
.PP
Definition at line \fB2413\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2414         {
2415             ProgramCounter--;
2416             BreakOperation(false, 0xFFFA);
2417             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
2418 
2419             SetDisassembly();
2420         }
.fi
.SS "void Hardware\&.W65C02\&.PullFlagsOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The PLP Operation\&. Pull the status flags off the stack on sets the flags accordingly\&.  
.PP
Definition at line \fB2297\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2298         {
2299             var flags = PeekStack();
2300             CarryFlag = (flags & 0x01) != 0;
2301             ZeroFlag = (flags & 0x02) != 0;
2302             DisableInterruptFlag = (flags & 0x04) != 0;
2303             DecimalFlag = (flags & 0x08) != 0;
2304             OverflowFlag = (flags & 0x40) != 0;
2305             NegativeFlag = (flags & 0x80) != 0;
2306 
2307 
2308         }
.fi
.SS "void Hardware\&.W65C02\&.PushFlagsOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The PSP Operation\&. Pushes the Status Flags to the stack  
.PP
Definition at line \fB2289\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2290         {
2291             PokeStack(ConvertFlagsToByte(true));
2292         }
.fi
.SS "void Hardware\&.W65C02\&.Reset ()\fC [inline]\fP"

.PP
Initializes the processor to its default state\&.  
.PP
Definition at line \fB152\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
153         {
154             ResetCycleCount();
155             StackPointer = 0x1FD;
156             //Set the Program Counter to the Reset Vector Address\&.
157             ProgramCounter = 0xFFFC;
158             //Reset the Program Counter to the Address contained in the Reset Vector
159             ProgramCounter = (MemoryMap\&.Read(ProgramCounter) | (MemoryMap\&.Read(ProgramCounter + 1) << 8));
160             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
161             //SetDisassembly();
162             DisableInterruptFlag = true;
163             _previousInterrupt = false;
164             TriggerNmi = false;
165             TriggerIRQ = false;
166         }
.fi
.SS "void Hardware\&.W65C02\&.ResetCycleCount ()\fC [inline]\fP"

.PP
Resets the Cycle Count back to 0  
.PP
Definition at line \fB229\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
230         {
231             _cycleCount = 0;
232         }
.fi
.SS "void Hardware\&.W65C02\&.ReturnFromInterruptOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The RTI routine\&. Called when returning from a BRK opertion\&. Note: when called after a BRK operation the Program Counter is not set to the location after the BRK, it is set +1  
.PP
Definition at line \fB2390\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2391         {
2392             MemoryMap\&.Read(++ProgramCounter);
2393             StackPointer++;
2394             IncrementCycleCount();
2395 
2396             PullFlagsOperation();
2397             StackPointer++;
2398             IncrementCycleCount();
2399 
2400             var lowBit = PeekStack();
2401             StackPointer++;
2402             IncrementCycleCount();
2403 
2404             var highBit = PeekStack() << 8;
2405             IncrementCycleCount();
2406 
2407             ProgramCounter = (highBit | lowBit);
2408         }
.fi
.SS "void Hardware\&.W65C02\&.ReturnFromSubRoutineOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The RTS routine\&. Called when returning from a subroutine\&.  
.PP
Definition at line \fB2333\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2334         {
2335             MemoryMap\&.Read(++ProgramCounter);
2336             StackPointer++;
2337             IncrementCycleCount();
2338 
2339             var lowBit = PeekStack();
2340             StackPointer++;
2341             IncrementCycleCount();
2342 
2343             var highBit = PeekStack() << 8;
2344             IncrementCycleCount();
2345 
2346             ProgramCounter = (highBit | lowBit) + 1;
2347             IncrementCycleCount();
2348         }
.fi
.SS "void Hardware\&.W65C02\&.RolOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The ROL operation\&. Performs a rotate left operation on a value in memory\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2161\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2162         {
2163             int value;
2164             var memoryAddress = 0;
2165             if (addressingMode == AddressingMode\&.Accumulator)
2166             {
2167                 //Dummy MemoryMap\&.Read
2168                 MemoryMap\&.Read(ProgramCounter + 1);
2169                 value = Accumulator;
2170             }
2171             else
2172             {
2173                 memoryAddress = GetAddressByAddressingMode(addressingMode);
2174                 value = MemoryMap\&.Read(memoryAddress);
2175             }
2176 
2177             //Dummy Write
2178             if (addressingMode != AddressingMode\&.Accumulator)
2179             {
2180                 MemoryMap\&.Write(memoryAddress, (byte)value);
2181             }
2182 
2183             //Store the carry flag before shifting it
2184             var newCarry = (0x80 & value) != 0;
2185 
2186             //The And here ensures that if the value is greater than 255 it wraps properly\&.
2187             value = (value << 1) & 0xFE;
2188 
2189             if (CarryFlag)
2190                 value = value | 0x01;
2191 
2192             CarryFlag = newCarry;
2193 
2194             SetZeroFlag(value);
2195             SetNegativeFlag(value);
2196 
2197 
2198             if (addressingMode == AddressingMode\&.Accumulator)
2199                 Accumulator = value;
2200             else
2201             {
2202                 MemoryMap\&.Write(memoryAddress, (byte)value);
2203             }
2204         }
.fi
.SS "void Hardware\&.W65C02\&.RorOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The ROR operation\&. Performs a rotate right operation on a value in memory\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2210\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2211         {
2212             int value;
2213             var memoryAddress = 0;
2214             if (addressingMode == AddressingMode\&.Accumulator)
2215             {
2216                 //Dummy MemoryMap\&.Read
2217                 MemoryMap\&.Read(ProgramCounter + 1);
2218                 value = Accumulator;
2219             }
2220             else
2221             {
2222                 memoryAddress = GetAddressByAddressingMode(addressingMode);
2223                 value = MemoryMap\&.Read(memoryAddress);
2224             }
2225 
2226             //Dummy Write
2227             if (addressingMode != AddressingMode\&.Accumulator)
2228             {
2229                 MemoryMap\&.Write(memoryAddress, (byte)value);
2230             }
2231 
2232             //Store the carry flag before shifting it
2233             var newCarry = (0x01 & value) != 0;
2234 
2235             value = (value >> 1);
2236 
2237             //If the carry flag is set then 0x
2238             if (CarryFlag)
2239                 value = value | 0x80;
2240 
2241             CarryFlag = newCarry;
2242 
2243             SetZeroFlag(value);
2244             SetNegativeFlag(value);
2245 
2246             if (addressingMode == AddressingMode\&.Accumulator)
2247                 Accumulator = value;
2248             else
2249             {
2250                 MemoryMap\&.Write(memoryAddress, (byte)value);
2251             }
2252         }
.fi
.SS "void Hardware\&.W65C02\&.SetDisassembly ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB1529\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1530         {
1531             if (!_logger\&.IsDebugEnabled)
1532                 return;
1533 
1534             var addressMode = GetAddressingMode();
1535 
1536             var currentProgramCounter = ProgramCounter;
1537 
1538             currentProgramCounter = WrapProgramCounter(++currentProgramCounter);
1539             int? address1 = MemoryMap\&.Read(currentProgramCounter);
1540 
1541             currentProgramCounter = WrapProgramCounter(++currentProgramCounter);
1542             int? address2 = MemoryMap\&.Read(currentProgramCounter);
1543 
1544             string disassembledStep = string\&.Empty;
1545 
1546             switch (addressMode)
1547             {
1548                 case AddressingMode\&.Absolute:
1549                     {
1550                         disassembledStep = string\&.Format("${0}{1}", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1551                         break;
1552                     }
1553                 case AddressingMode\&.AbsoluteX:
1554                     {
1555                         disassembledStep = string\&.Format("${0}{1},X", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1556                         break;
1557                     }
1558                 case AddressingMode\&.AbsoluteY:
1559                     {
1560                         disassembledStep = string\&.Format("${0}{1},Y", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1561                         break;
1562                     }
1563                 case AddressingMode\&.Accumulator:
1564                     {
1565                         address1 = null;
1566                         address2 = null;
1567 
1568                         disassembledStep = "A";
1569                         break;
1570                     }
1571                 case AddressingMode\&.Immediate:
1572                     {
1573                         disassembledStep = string\&.Format("#${0}", address1\&.Value\&.ToString("X")\&.PadLeft(4, '0'));
1574                         address2 = null;
1575                         break;
1576                     }
1577                 case AddressingMode\&.Implied:
1578                     {
1579                         address1 = null;
1580                         address2 = null;
1581                         break;
1582                     }
1583                 case AddressingMode\&.Indirect:
1584                     {
1585                         disassembledStep = string\&.Format("(${0}{1})", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1586                         break;
1587                     }
1588                 case AddressingMode\&.IndirectX:
1589                     {
1590                         address2 = null;
1591 
1592                         disassembledStep = string\&.Format("(${0},X)", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1593                         break;
1594                     }
1595                 case AddressingMode\&.IndirectY:
1596                     {
1597                         address2 = null;
1598 
1599                         disassembledStep = string\&.Format("(${0}),Y", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1600                         break;
1601                     }
1602                 case AddressingMode\&.Relative:
1603                     {
1604                         var valueToMove = (byte)address1\&.Value;
1605 
1606                         var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;
1607 
1608                         var newProgramCounter = ProgramCounter + movement;
1609 
1610                         //This makes sure that we always land on the correct spot for a positive number
1611                         if (movement >= 0)
1612                             newProgramCounter++;
1613 
1614                         var stringAddress = ProgramCounter\&.ToString("X")\&.PadLeft(4, '0');
1615 
1616                         address1 = int\&.Parse(stringAddress\&.Substring(0, 2), NumberStyles\&.AllowHexSpecifier);
1617                         address2 = int\&.Parse(stringAddress\&.Substring(2, 2), NumberStyles\&.AllowHexSpecifier);
1618 
1619                         disassembledStep = string\&.Format("${0}", newProgramCounter\&.ToString("X")\&.PadLeft(4, '0'));
1620 
1621                         break;
1622                     }
1623                 case AddressingMode\&.ZeroPage:
1624                     {
1625                         address2 = null;
1626 
1627                         disassembledStep = string\&.Format("${0}", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1628                         break;
1629                     }
1630                 case AddressingMode\&.ZeroPageX:
1631                     {
1632                         address2 = null;
1633 
1634                         disassembledStep = string\&.Format("${0},X", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1635                         break;
1636                     }
1637                 case AddressingMode\&.ZeroPageY:
1638                     {
1639                         address2 = null;
1640 
1641                         disassembledStep = string\&.Format("${0},Y", address1\&.Value\&.ToString("X")\&.PadLeft(4, '0'));
1642                         break;
1643                     }
1644                 default:
1645                     throw new InvalidEnumArgumentException("Invalid Addressing Mode");
1646 
1647             }
1648 
1649 
1650             CurrentDisassembly = new Disassembly
1651             {
1652                 HighAddress = address2\&.HasValue ? address2\&.Value\&.ToString("X")\&.PadLeft(2, '0') : string\&.Empty,
1653                 LowAddress = address1\&.HasValue ? address1\&.Value\&.ToString("X")\&.PadLeft(2, '0') : string\&.Empty,
1654                 OpCodeString = CurrentOpCode\&.ConvertOpCodeIntoString(),
1655                 DisassemblyOutput = disassembledStep
1656             };
1657 
1658             _logger\&.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}",
1659                  ProgramCounter\&.ToString("X")\&.PadLeft(4, '0'),
1660                  CurrentOpCode\&.ToString("X")\&.PadLeft(2, '0'),
1661                  CurrentDisassembly\&.LowAddress,
1662                  CurrentDisassembly\&.HighAddress,
1663 
1664                  CurrentDisassembly\&.OpCodeString,
1665                  CurrentDisassembly\&.DisassemblyOutput\&.PadRight(10, ' '),
1666 
1667                  Accumulator\&.ToString("X")\&.PadLeft(3, '0'),
1668                      XRegister\&.ToString("X")\&.PadLeft(3, '0'),
1669                      YRegister\&.ToString("X")\&.PadLeft(3, '0'),
1670                      StackPointer\&.ToString("X")\&.PadLeft(3, '0'),
1671                      Convert\&.ToInt16(NegativeFlag),
1672                      Convert\&.ToInt16(OverflowFlag),
1673                      0,
1674                      Convert\&.ToInt16(DecimalFlag),
1675                      Convert\&.ToInt16(DisableInterruptFlag),
1676                      Convert\&.ToInt16(ZeroFlag),
1677                      Convert\&.ToInt16(CarryFlag));
1678         }
.fi
.SS "void Hardware\&.W65C02\&.SetNegativeFlag (int value)\fC [inline]\fP, \fC [protected]\fP"

.PP
Sets the IsSignNegative register  
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP 
.RE
.PP

.PP
Definition at line \fB1318\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1319         {
1320             //on the 6502, any value greater than 127 is negative\&. 128 = 1000000 in Binary\&. the 8th bit is set, therefore the number is a negative number\&.
1321             NegativeFlag = value > 127;
1322         }
.fi
.SS "void Hardware\&.W65C02\&.SetZeroFlag (int value)\fC [inline]\fP, \fC [protected]\fP"

.PP
Sets the IsResultZero register  
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP 
.RE
.PP

.PP
Definition at line \fB1328\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1329         {
1330             ZeroFlag = value == 0;
1331         }
.fi
.SS "void Hardware\&.W65C02\&.SubtractWithBorrowOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [protected]\fP"

.PP
The SBC operation\&. Performs a subtract with carry operation on the accumulator and a value in memory\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2258\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2259         {
2260             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2261             var newValue = DecimalFlag ? int\&.Parse(Accumulator\&.ToString("x")) - int\&.Parse(memoryValue\&.ToString("x")) - (CarryFlag ? 0 : 1) : Accumulator - memoryValue - (CarryFlag ? 0 : 1);
2262 
2263             CarryFlag = newValue >= 0;
2264 
2265             if (DecimalFlag)
2266             {
2267                 if (newValue < 0)
2268                     newValue += 100;
2269 
2270                 newValue = (int)Convert\&.ToInt64(string\&.Concat("0x", newValue), 16);
2271             }
2272             else
2273             {
2274                 OverflowFlag = (((Accumulator ^ newValue) & 0x80) != 0) && (((Accumulator ^ memoryValue) & 0x80) != 0);
2275 
2276                 if (newValue < 0)
2277                     newValue += 256;
2278             }
2279 
2280             SetNegativeFlag(newValue);
2281             SetZeroFlag(newValue);
2282 
2283             Accumulator = newValue;
2284         }
.fi
.SS "int Hardware\&.W65C02\&.WrapProgramCounter (int value)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB1680\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1681         {
1682             return value & 0xFFFF;
1683         }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int Hardware\&.W65C02\&._cycleCount\fC [private]\fP"

.PP
Definition at line \fB19\fP of file \fBW65C02\&.cs\fP\&.
.SS "bool Hardware\&.W65C02\&._interrupt\fC [private]\fP"

.PP
Definition at line \fB21\fP of file \fBW65C02\&.cs\fP\&.
.SS "readonly ILogger Hardware\&.W65C02\&._logger = LogManager\&.GetLogger('Processor')\fC [private]\fP"

.PP
Definition at line \fB16\fP of file \fBW65C02\&.cs\fP\&.
.SS "bool Hardware\&.W65C02\&._previousInterrupt\fC [private]\fP"

.PP
Definition at line \fB20\fP of file \fBW65C02\&.cs\fP\&.
.SS "int Hardware\&.W65C02\&._programCounter\fC [private]\fP"

.PP
Definition at line \fB17\fP of file \fBW65C02\&.cs\fP\&.
.SS "int Hardware\&.W65C02\&._stackPointer\fC [private]\fP"

.PP
Definition at line \fB18\fP of file \fBW65C02\&.cs\fP\&.
.SS "bool Hardware\&.W65C02\&.isRunning"

.PP
Checks shether the emulated computer is running or not\&.  
.PP
Definition at line \fB26\fP of file \fBW65C02\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "int Hardware\&.W65C02\&.Accumulator\fC [get]\fP, \fC [protected set]\fP"

.PP
The Accumulator\&. This value is implemented as an integer intead of a byte\&. This is done so we can detect wrapping of the value and set the correct number of cycles\&.  
.PP
Definition at line \fB34\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
34 { get; protected set; }
.fi
.SS "bool Hardware\&.W65C02\&.CarryFlag\fC [get]\fP, \fC [protected set]\fP"

.PP
This is the carry flag\&. when adding, if the result is greater than 255 or 99 in BCD Mode, then this bit is enabled\&. In subtraction this is reversed and set to false if a borrow is required IE the result is less than 0  
.PP
Definition at line \fB94\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
94 { get; protected set; }
.fi
.SS "\fBDisassembly\fP Hardware\&.W65C02\&.CurrentDisassembly\fC [get]\fP, \fC [private set]\fP"

.PP
The disassembly of the current operation\&. This value is only set when the CPU is built in debug mode\&.  
.PP
Definition at line \fB54\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
54 { get; private set; }
.fi
.SS "int Hardware\&.W65C02\&.CurrentOpCode\fC [get]\fP, \fC [private set]\fP"

.PP
The Current Op Code being executed by the system  
.PP
Definition at line \fB49\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
49 { get; private set; }
.fi
.SS "Action Hardware\&.W65C02\&.CycleCountIncrementedAction\fC [get]\fP, \fC [set]\fP"

.PP
An external action that occurs when the cycle count is incremented  
.PP
Definition at line \fB87\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
87 { get; set; }
.fi
.SS "bool Hardware\&.W65C02\&.DecimalFlag\fC [get]\fP, \fC [private set]\fP"

.PP
Binary Coded Decimal Mode is set/cleared via this flag\&. when this mode is in effect, a byte represents a number from 0-99\&.  
.PP
Definition at line \fB112\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
112 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.DisableInterruptFlag\fC [get]\fP, \fC [private set]\fP"

.PP
This determines if Interrupts are currently disabled\&. This flag is turned on during a reset to prevent an interrupt from occuring during startup/Initialization\&. If this flag is true, then the IRQ pin is ignored\&.  
.PP
Definition at line \fB106\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
106 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.NegativeFlag\fC [get]\fP, \fC [private set]\fP"

.PP
Set to true if the result of an operation is negative in ADC and SBC operations\&. Remember that 128-256 represent negative numbers when doing signed math\&. In shift operations the sign holds the carry\&.  
.PP
Definition at line \fB128\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
128 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.OverflowFlag\fC [get]\fP, \fC [protected set]\fP"

.PP
This property is set when an overflow occurs\&. An overflow happens if the high bit(7) changes during the operation\&. Remember that values from 128-256 are negative values as the high bit is set to 1\&. Examples: 64 + 64 = -128 -128 + -128 = 0  
.PP
Definition at line \fB121\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
121 { get; protected set; }
.fi
.SS "int Hardware\&.W65C02\&.ProgramCounter\fC [get]\fP, \fC [private set]\fP"

.PP
Points to the Current Address of the instruction being executed by the system\&. The PC wraps when the value is greater than 65535, or less than 0\&.  
.PP
Definition at line \fB60\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
61         {
62             get { return _programCounter; }
63             private set { _programCounter = WrapProgramCounter(value); }
64         }
.fi
.SS "int Hardware\&.W65C02\&.StackPointer\fC [get]\fP, \fC [private set]\fP"

.PP
Points to the Current Position of the Stack\&. This value is a 00-FF value but is offset to point to the location in memory where the stack resides\&.  
.PP
Definition at line \fB70\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
71         {
72             get { return _stackPointer; }
73             private set
74             {
75                 if (value > 0xFF)
76                     _stackPointer = value - 0x100;
77                 else if (value < 0x00)
78                     _stackPointer = value + 0x100;
79                 else
80                     _stackPointer = value;
81             }
82         }
.fi
.SS "bool Hardware\&.W65C02\&.TriggerIRQ\fC [get]\fP, \fC [private set]\fP"

.PP
Set to true when an IRQ has occurred and is being processed by the CPU\&. 
.PP
Definition at line \fB136\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
136 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.TriggerNmi\fC [get]\fP, \fC [set]\fP"

.PP
Set to true when an NMI should occur  
.PP
Definition at line \fB133\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
133 { get; set; }
.fi
.SS "int Hardware\&.W65C02\&.XRegister\fC [get]\fP, \fC [private set]\fP"

.PP
The X Index Register  
.PP
Definition at line \fB39\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
39 { get; private set; }
.fi
.SS "int Hardware\&.W65C02\&.YRegister\fC [get]\fP, \fC [private set]\fP"

.PP
The Y Index Register  
.PP
Definition at line \fB44\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
44 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.ZeroFlag\fC [get]\fP, \fC [private set]\fP"

.PP
Is true if one of the registers is set to zero\&.  
.PP
Definition at line \fB99\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
99 { get; private set; }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for WolfNet 6502 WorkBench Computer Emulator from the source code\&.
