.TH "Emulator.ViewModel.MainViewModel" 3 "Wed Sep 28 2022" "Version beta" "WolfNet 6502 WorkBench Computer Emulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Emulator.ViewModel.MainViewModel \- The Main \fBViewModel\fP   

.SH SYNOPSIS
.br
.PP
.PP
Inherits ViewModelBase\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMainViewModel\fP ()"
.br
.RI "Creates a new Instance of the \fBMainViewModel\fP\&.  "
.ti -1c
.RI "void \fBOnLoad\fP (Object sender, RoutedEventArgs e)"
.br
.ti -1c
.RI "void \fBOnClose\fP (Object sender, CancelEventArgs e)"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "\fBHM62256\fP \fBHM62256\fP\fC [get, set]\fP"
.br
.RI "The 62256 RAM\&.  "
.ti -1c
.RI "\fBW65C02\fP \fBW65C02\fP\fC [get, private set]\fP"
.br
.RI "The 65C02 Processor\&.  "
.ti -1c
.RI "\fBW65C22\fP \fBW65C22\fP\fC [get, private set]\fP"
.br
.RI "General Purpose I/O, Shift Registers and Timers\&.  "
.ti -1c
.RI "\fBW65C22\fP \fBMM65SIB\fP\fC [get, private set]\fP"
.br
.RI "Memory management and 65SIB\&.  "
.ti -1c
.RI "\fBW65C51\fP \fBW65C51\fP\fC [get, private set]\fP"
.br
.RI "The ACIA serial interface\&.  "
.ti -1c
.RI "\fBAT28CXX\fP \fBAT28C64\fP\fC [get, private set]\fP"
.br
.RI "The AT28C010 ROM\&.  "
.ti -1c
.RI "\fBAT28CXX\fP \fBAT28C010\fP\fC [get, private set]\fP"
.br
.RI "The AT28C010 ROM\&.  "
.ti -1c
.RI "\fBMultiThreadedObservableCollection\fP< \fBMemoryRowModel\fP > \fBMemoryPage\fP\fC [get, set]\fP"
.br
.RI "The Current Memory Page  "
.ti -1c
.RI "\fBMultiThreadedObservableCollection\fP< \fBOutputLog\fP > \fBOutputLog\fP\fC [get, private set]\fP"
.br
.RI "The output log  "
.ti -1c
.RI "\fBMultiThreadedObservableCollection\fP< \fBBreakpoint\fP > \fBBreakpoints\fP\fC [get, set]\fP"
.br
.RI "The Breakpoints  "
.ti -1c
.RI "\fBBreakpoint\fP \fBSelectedBreakpoint\fP\fC [get, set]\fP"
.br
.RI "The Currently Selected Breakpoint  "
.ti -1c
.RI "\fBRomFileModel\fP \fBRomFile\fP\fC [get, set]\fP"
.br
.RI "The currently loaded binary file\&. (If it is indeed loaded, that is\&.)  "
.ti -1c
.RI "string \fBCurrentDisassembly\fP\fC [get]\fP"
.br
.RI "The Current Disassembly  "
.ti -1c
.RI "int \fBNumberOfCycles\fP\fC [get, private set]\fP"
.br
.RI "The number of cycles\&.  "
.ti -1c
.RI "bool \fBIsRunning\fP\fC [get, set]\fP"
.br
.RI "Is the Prorgam Running  "
.ti -1c
.RI "bool \fBIsRomLoaded\fP\fC [get, set]\fP"
.br
.RI "Is the banked ROM Loaded\&.  "
.ti -1c
.RI "int \fBCpuSpeed\fP\fC [get, set]\fP"
.br
.RI "The Slider CPU Speed  "
.ti -1c
.RI "static \fBSettingsModel\fP \fBSettingsModel\fP\fC [get, set]\fP"
.br
.RI "The \fBModel\fP used for saving, loading and using data from Settings\&.xml  "
.ti -1c
.RI "RelayCommand \fBStepCommand\fP\fC [get, set]\fP"
.br
.RI "RelayCommand for Stepping through the progam one instruction at a time\&.  "
.ti -1c
.RI "RelayCommand \fBMemoryVisualCommand\fP\fC [get, set]\fP"
.br
.RI "RelayCommand for opening the Memory View window\&.  "
.ti -1c
.RI "RelayCommand \fBResetCommand\fP\fC [get, set]\fP"
.br
.RI "Relay Command to Reset the Program back to its initial state\&.  "
.ti -1c
.RI "RelayCommand \fBRunPauseCommand\fP\fC [get, set]\fP"
.br
.RI "Relay Command that Run/Pauses Execution  "
.ti -1c
.RI "RelayCommand \fBUpdateMemoryMapCommand\fP\fC [get, set]\fP"
.br
.RI "Relay Command that updates the Memory Map when the Page changes  "
.ti -1c
.RI "RelayCommand \fBAddBreakPointCommand\fP\fC [get, set]\fP"
.br
.RI "The Relay Command that adds a new breakpoint  "
.ti -1c
.RI "RelayCommand \fBAboutCommand\fP\fC [get, set]\fP"
.br
.RI "The Relay Command that opens the About window\&.  "
.ti -1c
.RI "RelayCommand \fBRemoveBreakPointCommand\fP\fC [get, set]\fP"
.br
.RI "The Relay Command that Removes an existing breakpoint\&.  "
.ti -1c
.RI "RelayCommand \fBSettingsCommand\fP\fC [get, set]\fP"
.br
.RI "The Command that loads or saves the settings\&.  "
.ti -1c
.RI "RelayCommand< \fBIClosable\fP > \fBCloseCommand\fP\fC [get, private set]\fP"
.br
.RI "The Command that loads or saves the settings\&.  "
.ti -1c
.RI "string \fBCurrentSerialPort\fP\fC [get]\fP"
.br
.RI "The current serial port object name\&.  "
.ti -1c
.RI "string \fBWindowTitle\fP\fC [get]\fP"
.br
.RI "The title for the main window\&.  "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBClose\fP (\fBIClosable\fP window)"
.br
.ti -1c
.RI "void \fBBinaryLoadedNotification\fP (NotificationMessage< \fBRomFileModel\fP > notificationMessage)"
.br
.ti -1c
.RI "void \fBStateLoadedNotifcation\fP (NotificationMessage< \fBStateFileModel\fP > notificationMessage)"
.br
.ti -1c
.RI "void \fBGenericNotifcation\fP (NotificationMessage notificationMessage)"
.br
.ti -1c
.RI "void \fBSettingsAppliedNotifcation\fP (NotificationMessage< \fBSettingsModel\fP > notificationMessage)"
.br
.ti -1c
.RI "void \fBReset\fP ()"
.br
.ti -1c
.RI "void \fBStep\fP ()"
.br
.ti -1c
.RI "void \fBUpdateUi\fP ()"
.br
.ti -1c
.RI "void \fBStepProcessor\fP ()"
.br
.ti -1c
.RI "\fBOutputLog\fP \fBGetOutputLog\fP ()"
.br
.ti -1c
.RI "void \fBRunPause\fP ()"
.br
.ti -1c
.RI "void \fBBackgroundWorkerDoWork\fP (object sender, DoWorkEventArgs e)"
.br
.ti -1c
.RI "bool \fBIsBreakPointTriggered\fP ()"
.br
.ti -1c
.RI "int \fBGetLogModValue\fP ()"
.br
.ti -1c
.RI "int \fBGetSleepValue\fP ()"
.br
.ti -1c
.RI "void \fBUpdateMemoryPage\fP ()"
.br
.ti -1c
.RI "void \fBAbout\fP ()"
.br
.ti -1c
.RI "void \fBSettings\fP ()"
.br
.ti -1c
.RI "void \fBMemoryView\fP ()"
.br
.ti -1c
.RI "void \fBAddBreakPoint\fP ()"
.br
.ti -1c
.RI "void \fBRemoveBreakPoint\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "readonly BackgroundWorker \fB_backgroundWorker\fP"
.br
.ti -1c
.RI "bool \fB_breakpointTriggered\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Main \fBViewModel\fP  
.PP
Definition at line \fB26\fP of file \fBMainViewModel\&.cs\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Emulator\&.ViewModel\&.MainViewModel\&.MainViewModel ()\fC [inline]\fP"

.PP
Creates a new Instance of the \fBMainViewModel\fP\&.  
.PP
Definition at line \fB216\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
217         {
218             var _formatter = new XmlSerializer(typeof(SettingsModel));
219             Stream _stream = new FileStream(FileLocations\&.SettingsFile, FileMode\&.OpenOrCreate);
220             if (!((_stream == null) || (0 >= _stream\&.Length)))
221             {
222                 SettingsModel = (SettingsModel)_formatter\&.Deserialize(_stream);
223                 if ((SettingsModel\&.SettingsVersionMajor < Versioning\&.SettingsFile\&.Major) ||
224                     (SettingsModel\&.SettingsVersionMinor < Versioning\&.SettingsFile\&.Minor) ||
225                     (SettingsModel\&.SettingsVersionBuild < Versioning\&.SettingsFile\&.Build) ||
226                     (SettingsModel\&.SettingsVersionRevision < Versioning\&.SettingsFile\&.Revision))
227                 {
228                     MessageBox\&.Show("Settings file contains old information\&.\&.\&.\nDeleting old settings file\&.\&.\&.",
229                                     "Settings file stale!", MessageBoxButton\&.OKCancel, MessageBoxImage\&.Warning,
230                                     MessageBoxResult\&.OK);
231                     // Close the file, then delete it\&.
232                     _stream\&.Close();
233                     File\&.Delete(FileLocations\&.SettingsFile);
234                     SettingsModel = SettingsFile\&.CreateNew();
235                 }
236             }
237             else
238             {
239                 MessageBox\&.Show("Creating new settings file\&.\&.\&.");
240                 SettingsModel = SettingsFile\&.CreateNew();
241             }
242             _stream\&.Close();
243 
244             HM62256 = new HM62256(MemoryMap\&.BankedRam\&.TotalBanks, MemoryMap\&.BankedRam\&.Offset, MemoryMap\&.BankedRam\&.Length);
245             AT28C64 = new AT28CXX(MemoryMap\&.SharedRom\&.Offset, MemoryMap\&.SharedRom\&.Length, 1);
246             AT28C010 = new AT28CXX(MemoryMap\&.BankedRom\&.Offset, MemoryMap\&.BankedRom\&.Length, MemoryMap\&.BankedRom\&.TotalBanks);
247             W65C02 = new W65C02();
248             W65C51 = new W65C51(W65C02, MemoryMap\&.Devices\&.ACIA\&.Offset);
249             W65C51\&.Init(SettingsModel\&.ComPortName\&.ToString());
250             W65C22 = new W65C22(W65C02, MemoryMap\&.Devices\&.GPIO\&.Offset, MemoryMap\&.Devices\&.GPIO\&.Length);
251             W65C22\&.Init(1000);
252             MM65SIB = new W65C22(W65C02, MemoryMap\&.Devices\&.MM65SIB\&.Offset, MemoryMap\&.Devices\&.MM65SIB\&.Length);
253             MM65SIB\&.Init(1000);
254 
255             MemoryMap\&.Init(W65C02, W65C22, MM65SIB, W65C51, HM62256, AT28C010, AT28C64);
256 
257             // Now we can load the BIOS\&.
258             byte[][] _bios = AT28C64\&.ReadFile(FileLocations\&.BiosFile);
259             if (_bios == null)
260             {
261                 Environment\&.Exit(ExitCodes\&.NO_BIOS);
262             }
263             AT28C64\&.Load(_bios);
264 
265             AboutCommand = new RelayCommand(About);
266             AddBreakPointCommand = new RelayCommand(AddBreakPoint);
267             CloseCommand = new RelayCommand<IClosable>(Close);
268             MemoryVisualCommand = new RelayCommand(MemoryView);
269             RemoveBreakPointCommand = new RelayCommand(RemoveBreakPoint);
270             ResetCommand = new RelayCommand(Reset);
271             RunPauseCommand = new RelayCommand(RunPause);
272             SettingsCommand = new RelayCommand(Settings);
273             StepCommand = new RelayCommand(Step);
274 
275             Messenger\&.Default\&.Register<NotificationMessage>(this, GenericNotifcation);
276             Messenger\&.Default\&.Register<NotificationMessage<RomFileModel>>(this, BinaryLoadedNotification);
277             Messenger\&.Default\&.Register<NotificationMessage<SettingsModel>>(this, SettingsAppliedNotifcation);
278             Messenger\&.Default\&.Register<NotificationMessage<StateFileModel>>(this, StateLoadedNotifcation);
279 
280             MemoryPage = new MultiThreadedObservableCollection<MemoryRowModel>();
281             OutputLog = new MultiThreadedObservableCollection<OutputLog>();
282             Breakpoints = new MultiThreadedObservableCollection<Breakpoint>();
283 
284             UpdateMemoryPage();
285 
286             _backgroundWorker = new BackgroundWorker { WorkerSupportsCancellation = true, WorkerReportsProgress = false };
287             _backgroundWorker\&.DoWork += BackgroundWorkerDoWork;
288             Application\&.Current\&.MainWindow\&.Title = Versioning\&.Product\&.Title;
289             Application\&.Current\&.MainWindow\&.Closing += new CancelEventHandler(OnClose);
290             Application\&.Current\&.MainWindow\&.Loaded += new RoutedEventHandler(OnLoad);
291 
292             Reset();
293         }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.About ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB718\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
719         {
720             IsRunning = false;
721 
722             if (_backgroundWorker\&.IsBusy)
723                 _backgroundWorker\&.CancelAsync();
724 
725             MessageBox\&.Show(string\&.Format("{0}\n{1}\nVersion: {2}\nCompany: {3}", Versioning\&.Product\&.Name, Versioning\&.Product\&.Description, Versioning\&.Product\&.VersionString, Versioning\&.Product\&.Company), Versioning\&.Product\&.Title);
726         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.AddBreakPoint ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB743\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
744         {
745             Breakpoints\&.Add(new Breakpoint());
746             RaisePropertyChanged("Breakpoints");
747         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.BackgroundWorkerDoWork (object sender, DoWorkEventArgs e)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB589\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
590         {
591             var worker = sender as BackgroundWorker;
592             var outputLogs = new List<OutputLog>();
593 
594             while (true)
595             {
596                 if (worker != null && worker\&.CancellationPending || IsBreakPointTriggered())
597                 {
598                     e\&.Cancel = true;
599 
600                     RaisePropertyChanged("W65C02");
601 
602                     foreach (var log in outputLogs)
603                         OutputLog\&.Insert(0, log);
604 
605                     UpdateMemoryPage();
606                     return;
607                 }
608 
609                 StepProcessor();
610                 outputLogs\&.Add(GetOutputLog());
611 
612                 if (NumberOfCycles % GetLogModValue() == 0)
613                 {
614                     foreach (var log in outputLogs)
615                         OutputLog\&.Insert(0, log);
616 
617                     outputLogs\&.Clear();
618                     UpdateUi();
619                 }
620                 Thread\&.Sleep(GetSleepValue());
621             }
622         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.BinaryLoadedNotification (NotificationMessage< \fBRomFileModel\fP > notificationMessage)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB356\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
357         {
358             if (notificationMessage\&.Notification != "FileLoaded")
359             {
360                 return;
361             }
362 
363             // Load Banked ROM
364             AT28C010\&.Load(notificationMessage\&.Content\&.Rom);
365             IsRomLoaded = true;
366             RaisePropertyChanged("IsRomLoaded");
367 
368             Reset();
369         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.Close (\fBIClosable\fP window)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB348\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
349         {
350             if ((window != null) && (!IsRunning))
351             {
352                 Environment\&.Exit(ExitCodes\&.NO_ERROR);
353             }
354         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.GenericNotifcation (NotificationMessage notificationMessage)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB398\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
399         {
400             if (notificationMessage\&.Notification == "CloseFile")
401             {
402                 AT28C010\&.Clear();
403                 if (IsRunning) { RunPause(); }
404                 IsRomLoaded = false;
405                 RaisePropertyChanged("IsRomLoaded");
406                 return;
407             }
408             else if (notificationMessage\&.Notification == "LoadFile")
409             {
410                 var dialog = new OpenFileDialog
411                 {
412                     DefaultExt = "\&.bin",
413                     Filter =
414                                                     "All Files (*\&.bin, *\&.65C02)|*\&.bin;*\&.65C02|Binary Assembly (*\&.bin)|" +
415                                                     "*\&.bin|WolfNet 65C02 Emulator Save State (*\&.65C02)|*\&.65C02"
416                 };
417                 var result = dialog\&.ShowDialog();
418                 if (result != true)
419                 {
420                     return;
421                 }
422 
423                 if (Path\&.GetExtension(dialog\&.FileName\&.ToUpper()) == "\&.BIN")
424                 {
425                     byte[][] _rom = AT28C010\&.ReadFile(dialog\&.FileName);
426 
427                     Messenger\&.Default\&.Send(new NotificationMessage<RomFileModel>(new RomFileModel
428                     {
429                         Rom = _rom,
430                         RomBanks = AT28C010\&.Banks,
431                         RomBankSize = AT28C010\&.Length,
432                         RomFilePath = dialog\&.FileName,
433                         RomFileName = Path\&.GetFileName(dialog\&.FileName),
434                     }, "FileLoaded"));
435                 }
436                 else if (Path\&.GetExtension(dialog\&.FileName\&.ToUpper()) == "\&.6502")
437                 {
438                     var formatter = new BinaryFormatter();
439                     Stream stream = new FileStream(dialog\&.FileName, FileMode\&.Open);
440                     var fileModel = (StateFileModel)formatter\&.Deserialize(stream);
441 
442                     stream\&.Close();
443 
444                     Messenger\&.Default\&.Send(new NotificationMessage<StateFileModel>(fileModel, "StateLoaded"));
445                 }
446             }
447             else if (notificationMessage\&.Notification == "SaveState")
448             {
449                 var dialog = new SaveFileDialog
450                 {
451                     DefaultExt = "\&.65C02",
452                     Filter =
453                                                     "WolfNet W65C02 Emulator Save State (*\&.65C02)|*\&.65C02"
454                 };
455                 var result = dialog\&.ShowDialog();
456 
457                 if (result != true)
458                 {
459                     return;
460                 }
461 
462                 var formatter = new BinaryFormatter();
463                 Stream stream = new FileStream(dialog\&.FileName, FileMode\&.Create, FileAccess\&.Write, FileShare\&.None);
464 
465                 formatter\&.Serialize(stream, new StateFileModel
466                 {
467                     NumberOfCycles = NumberOfCycles,
468                     OutputLog = OutputLog,
469                     W65C02 = W65C02,
470                     W65C22 = W65C22,
471                     MM65SIB = MM65SIB,
472                     W65C51 = W65C51,
473                     AT28C010 = AT28C010,
474                     AT28C64 = AT28C64,
475                 });
476                 stream\&.Close();
477             }
478             else
479             {
480                 return;
481             }
482         }
.fi
.SS "int Emulator\&.ViewModel\&.MainViewModel\&.GetLogModValue ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB656\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
657         {
658             switch (CpuSpeed)
659             {
660                 case 0:
661                 case 1:
662                 case 2:
663                 case 3:
664                 case 4:
665                 case 5:
666                     return 1;
667                 case 6:
668                     return 5;
669                 case 7:
670                     return 20;
671                 case 8:
672                     return 30;
673                 case 9:
674                     return 40;
675                 case 10:
676                     return 50;
677                 default:
678                     return 5;
679             }
680         }
.fi
.SS "\fBOutputLog\fP Emulator\&.ViewModel\&.MainViewModel\&.GetOutputLog ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB558\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
559         {
560             if (W65C02\&.CurrentDisassembly == null)
561             {
562                 return new OutputLog(new Disassembly());
563             }
564 
565             return new OutputLog(W65C02\&.CurrentDisassembly)
566             {
567                 XRegister = W65C02\&.XRegister\&.ToString("X")\&.PadLeft(2, '0'),
568                 YRegister = W65C02\&.YRegister\&.ToString("X")\&.PadLeft(2, '0'),
569                 Accumulator = W65C02\&.Accumulator\&.ToString("X")\&.PadLeft(2, '0'),
570                 NumberOfCycles = NumberOfCycles,
571                 StackPointer = W65C02\&.StackPointer\&.ToString("X")\&.PadLeft(2, '0'),
572                 ProgramCounter = W65C02\&.ProgramCounter\&.ToString("X")\&.PadLeft(4, '0'),
573                 CurrentOpCode = W65C02\&.CurrentOpCode\&.ToString("X")\&.PadLeft(2, '0')
574             };
575         }
.fi
.SS "int Emulator\&.ViewModel\&.MainViewModel\&.GetSleepValue ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB682\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
683         {
684             switch (CpuSpeed)
685             {
686                 case 0:
687                     return 550;
688                 case 1:
689                     return 550;
690                 case 2:
691                     return 440;
692                 case 3:
693                     return 330;
694                 case 4:
695                     return 220;
696                 case 5:
697                     return 160;
698                 case 6:
699                     return 80;
700                 case 7:
701                     return 40;
702                 case 8:
703                     return 20;
704                 case 9:
705                     return 10;
706                 case 10:
707                     return 5;
708                 default:
709                     return 5;
710             }
711         }
.fi
.SS "bool Emulator\&.ViewModel\&.MainViewModel\&.IsBreakPointTriggered ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB624\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
625         {
626             //This prevents the Run Command from getting stuck after reaching a breakpoint
627             if (_breakpointTriggered)
628             {
629                 _breakpointTriggered = false;
630                 return false;
631             }
632 
633             foreach (var breakpoint in Breakpoints\&.Where(x => x\&.IsEnabled))
634             {
635                 if (!int\&.TryParse(breakpoint\&.Value, NumberStyles\&.AllowHexSpecifier, CultureInfo\&.InvariantCulture, out int value))
636                     continue;
637 
638                 if (breakpoint\&.Type == BreakpointType\&.NumberOfCycleType && value == NumberOfCycles)
639                 {
640                     _breakpointTriggered = true;
641                     RunPause();
642                     return true;
643                 }
644 
645                 if (breakpoint\&.Type == BreakpointType\&.ProgramCounterType && value == W65C02\&.ProgramCounter)
646                 {
647                     _breakpointTriggered = true;
648                     RunPause();
649                     return true;
650                 }
651             }
652 
653             return false;
654         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.MemoryView ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB738\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
739         {
740             Messenger\&.Default\&.Send(new NotificationMessage("MemoryVisualWindow"));
741         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.OnClose (Object sender, CancelEventArgs e)\fC [inline]\fP"

.PP
Definition at line \fB314\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
315         {
316             e\&.Cancel = false;
317             if (IsRunning)
318             {
319                 MessageBox\&.Show("You can't quit the emulator while it is actively running!",
320                                 "You can't do that!", MessageBoxButton\&.OK, MessageBoxImage\&.Stop);
321                 e\&.Cancel = true;
322                 return;
323             }
324 #if !DEBUG
325             else
326             {
327                 var result = MessageBox\&.Show("Are you sure you want to quit the emulator?",
328                                                 "To quit, or not to quit -- that is the question\&.",
329                                                 MessageBoxButton\&.YesNo, MessageBoxImage\&.Question,
330                                                 MessageBoxResult\&.No);
331                 if (result == MessageBoxResult\&.No)
332                 {
333                     e\&.Cancel = true;
334                     return;
335                 }
336             }
337 #endif
338             Stream stream = new FileStream(FileLocations\&.SettingsFile, FileMode\&.Create, FileAccess\&.Write, FileShare\&.None);
339             XmlSerializer XmlFormatter = new XmlSerializer(typeof(SettingsModel));
340             XmlFormatter\&.Serialize(stream, MainViewModel\&.SettingsModel);
341             stream\&.Flush();
342             stream\&.Close();
343             W65C51\&.Fini();
344         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.OnLoad (Object sender, RoutedEventArgs e)\fC [inline]\fP"

.PP
Definition at line \fB295\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
296         {
297 #if !DEBUG
298             if (Versioning\&.Product\&.Major < 1)
299             {
300                 var result = MessageBox\&.Show(String\&.Format("Thank you for using {0}\n" +
301                                                         "Be warned that this is a beta build\&.\n" +
302                                                         "It may break or have bugs\&.", Versioning\&.Product\&.Name),
303                                                         Versioning\&.Product\&.Title, MessageBoxButton\&.OKCancel,
304                                                         MessageBoxImage\&.Warning, MessageBoxResult\&.None);
305                 if (result == MessageBoxResult\&.Cancel)
306                 {
307                     // Exit without making any changes\&.
308                     Environment\&.Exit(ExitCodes\&.NO_ERROR);
309                 }
310             }
311 #endif
312         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.RemoveBreakPoint ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB749\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
750         {
751             if (SelectedBreakpoint == null)
752                 return;
753 
754             Breakpoints\&.Remove(SelectedBreakpoint);
755             SelectedBreakpoint = null;
756             RaisePropertyChanged("SelectedBreakpoint");
757         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.Reset ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB497\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
498         {
499             IsRunning = false;
500 
501             if (_backgroundWorker\&.IsBusy)
502                 _backgroundWorker\&.CancelAsync();
503 
504             // "Reset" the Hardware\&.\&.\&.
505             W65C02\&.Reset();
506             RaisePropertyChanged("W65C02");
507             W65C22\&.Reset();
508             RaisePropertyChanged("W65C22");
509             MM65SIB\&.Reset();
510             RaisePropertyChanged("MM65SIB");
511             W65C51\&.Reset();
512             RaisePropertyChanged("W65C51");
513             HM62256\&.Reset();
514             RaisePropertyChanged("HM62256");
515 
516             IsRunning = false;
517             NumberOfCycles = 0;
518             RaisePropertyChanged("NumberOfCycles");
519 
520             UpdateMemoryPage();
521             RaisePropertyChanged("MemoryPage");
522 
523             OutputLog\&.Clear();
524             RaisePropertyChanged("CurrentDisassembly");
525 
526             OutputLog\&.Insert(0, GetOutputLog());
527             UpdateUi();
528         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.RunPause ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB577\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
578         {
579             var isRunning = !IsRunning;
580 
581             if (isRunning)
582                 _backgroundWorker\&.RunWorkerAsync();
583             else
584                 _backgroundWorker\&.CancelAsync();
585 
586             IsRunning = !IsRunning;
587         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.Settings ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB728\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
729         {
730             IsRunning = false;
731 
732             if (_backgroundWorker\&.IsBusy)
733                 _backgroundWorker\&.CancelAsync();
734 
735             Messenger\&.Default\&.Send(new NotificationMessage<SettingsModel>(SettingsModel, "SettingsWindow"));
736         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.SettingsAppliedNotifcation (NotificationMessage< \fBSettingsModel\fP > notificationMessage)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB484\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
485         {
486             if (notificationMessage\&.Notification != "SettingsApplied")
487             {
488                 return;
489             }
490 
491             SettingsModel = notificationMessage\&.Content;
492             W65C51\&.Init(notificationMessage\&.Content\&.ComPortName);
493             RaisePropertyChanged("SettingsModel");
494             UpdateUi();
495         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.StateLoadedNotifcation (NotificationMessage< \fBStateFileModel\fP > notificationMessage)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB371\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
372         {
373             if (notificationMessage\&.Notification != "StateLoaded")
374             {
375                 return;
376             }
377 
378             Reset();
379 
380             OutputLog = new MultiThreadedObservableCollection<OutputLog>(notificationMessage\&.Content\&.OutputLog);
381             RaisePropertyChanged("OutputLog");
382 
383             NumberOfCycles = notificationMessage\&.Content\&.NumberOfCycles;
384 
385             W65C02 = notificationMessage\&.Content\&.W65C02;
386             W65C22 = notificationMessage\&.Content\&.W65C22;
387             MM65SIB = notificationMessage\&.Content\&.MM65SIB;
388             W65C51 = notificationMessage\&.Content\&.W65C51;
389             AT28C010 = notificationMessage\&.Content\&.AT28C010;
390             AT28C64 = notificationMessage\&.Content\&.AT28C64;
391             UpdateMemoryPage();
392             UpdateUi();
393 
394             IsRomLoaded = true;
395             RaisePropertyChanged("IsRomLoaded");
396         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.Step ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB530\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
531         {
532             IsRunning = false;
533 
534             if (_backgroundWorker\&.IsBusy)
535                 _backgroundWorker\&.CancelAsync();
536 
537             StepProcessor();
538             UpdateMemoryPage();
539 
540             OutputLog\&.Insert(0, GetOutputLog());
541             UpdateUi();
542         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.StepProcessor ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB552\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
553         {
554             W65C02\&.NextStep();
555             NumberOfCycles = W65C02\&.GetCycleCount();
556         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.UpdateMemoryPage ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB713\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
714         {
715             Messenger\&.Default\&.Send(new NotificationMessage("UpdateMemoryPage"));
716         }
.fi
.SS "void Emulator\&.ViewModel\&.MainViewModel\&.UpdateUi ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB544\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
545         {
546             RaisePropertyChanged("W65C02");
547             RaisePropertyChanged("NumberOfCycles");
548             RaisePropertyChanged("CurrentDisassembly");
549             RaisePropertyChanged("MemoryPage");
550         }
.fi
.SH "Member Data Documentation"
.PP 
.SS "readonly BackgroundWorker Emulator\&.ViewModel\&.MainViewModel\&._backgroundWorker\fC [private]\fP"

.PP
Definition at line \fB29\fP of file \fBMainViewModel\&.cs\fP\&.
.SS "bool Emulator\&.ViewModel\&.MainViewModel\&._breakpointTriggered\fC [private]\fP"

.PP
Definition at line \fB30\fP of file \fBMainViewModel\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.AboutCommand\fC [get]\fP, \fC [set]\fP"

.PP
The Relay Command that opens the About window\&.  
.PP
Definition at line \fB178\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
178 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.AddBreakPointCommand\fC [get]\fP, \fC [set]\fP"

.PP
The Relay Command that adds a new breakpoint  
.PP
Definition at line \fB173\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
173 { get; set; }
.fi
.SS "\fBAT28CXX\fP Emulator\&.ViewModel\&.MainViewModel\&.AT28C010\fC [get]\fP, \fC [private set]\fP"

.PP
The AT28C010 ROM\&.  
.PP
Definition at line \fB67\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
67 { get; private set; }
.fi
.SS "\fBAT28CXX\fP Emulator\&.ViewModel\&.MainViewModel\&.AT28C64\fC [get]\fP, \fC [private set]\fP"

.PP
The AT28C010 ROM\&.  
.PP
Definition at line \fB62\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
62 { get; private set; }
.fi
.SS "\fBMultiThreadedObservableCollection\fP<\fBBreakpoint\fP> Emulator\&.ViewModel\&.MainViewModel\&.Breakpoints\fC [get]\fP, \fC [set]\fP"

.PP
The Breakpoints  
.PP
Definition at line \fB82\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
82 { get; set; }
.fi
.SS "RelayCommand<\fBIClosable\fP> Emulator\&.ViewModel\&.MainViewModel\&.CloseCommand\fC [get]\fP, \fC [private set]\fP"

.PP
The Command that loads or saves the settings\&.  
.PP
Definition at line \fB193\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
193 { get; private set; }
.fi
.SS "int Emulator\&.ViewModel\&.MainViewModel\&.CpuSpeed\fC [get]\fP, \fC [set]\fP"

.PP
The Slider CPU Speed  
.PP
Definition at line \fB138\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
138 { get; set; }
.fi
.SS "string Emulator\&.ViewModel\&.MainViewModel\&.CurrentDisassembly\fC [get]\fP"

.PP
The Current Disassembly  
.PP
Definition at line \fB97\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
98         {
99             get
100             {
101                 if (W65C02\&.CurrentDisassembly != null)
102                 {
103                     return string\&.Format("{0} {1}", W65C02\&.CurrentDisassembly\&.OpCodeString, W65C02\&.CurrentDisassembly\&.DisassemblyOutput);
104                 }
105                 else
106                 {
107                     return string\&.Empty;
108                 }
109             }
110         }
.fi
.SS "string Emulator\&.ViewModel\&.MainViewModel\&.CurrentSerialPort\fC [get]\fP"

.PP
The current serial port object name\&.  
.PP
Definition at line \fB198\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
199         {
200             get
201             {
202                 return W65C51\&.ObjectName;
203             }
204         }
.fi
.SS "\fBHM62256\fP Emulator\&.ViewModel\&.MainViewModel\&.HM62256\fC [get]\fP, \fC [set]\fP, \fC [private]\fP"

.PP
The 62256 RAM\&.  
.PP
Definition at line \fB37\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
37 { get; set; }
.fi
.SS "bool Emulator\&.ViewModel\&.MainViewModel\&.IsRomLoaded\fC [get]\fP, \fC [set]\fP"

.PP
Is the banked ROM Loaded\&.  
.PP
Definition at line \fB133\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
133 { get; set; }
.fi
.SS "bool Emulator\&.ViewModel\&.MainViewModel\&.IsRunning\fC [get]\fP, \fC [set]\fP"

.PP
Is the Prorgam Running  
.PP
Definition at line \fB120\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
121         {
122             get { return W65C02\&.isRunning; }
123             set
124             {
125                 W65C02\&.isRunning = value;
126                 RaisePropertyChanged("IsRunning");
127             }
128         }
.fi
.SS "\fBMultiThreadedObservableCollection\fP<\fBMemoryRowModel\fP> Emulator\&.ViewModel\&.MainViewModel\&.MemoryPage\fC [get]\fP, \fC [set]\fP"

.PP
The Current Memory Page  
.PP
Definition at line \fB72\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
72 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.MemoryVisualCommand\fC [get]\fP, \fC [set]\fP"

.PP
RelayCommand for opening the Memory View window\&.  
.PP
Definition at line \fB153\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
153 { get; set; }
.fi
.SS "\fBW65C22\fP Emulator\&.ViewModel\&.MainViewModel\&.MM65SIB\fC [get]\fP, \fC [private set]\fP"

.PP
Memory management and 65SIB\&.  
.PP
Definition at line \fB52\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
52 { get; private set; }
.fi
.SS "int Emulator\&.ViewModel\&.MainViewModel\&.NumberOfCycles\fC [get]\fP, \fC [private set]\fP"

.PP
The number of cycles\&.  
.PP
Definition at line \fB115\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
115 { get; private set; }
.fi
.SS "\fBMultiThreadedObservableCollection\fP<\fBOutputLog\fP> Emulator\&.ViewModel\&.MainViewModel\&.OutputLog\fC [get]\fP, \fC [private set]\fP"

.PP
The output log  
.PP
Definition at line \fB77\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
77 { get; private set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.RemoveBreakPointCommand\fC [get]\fP, \fC [set]\fP"

.PP
The Relay Command that Removes an existing breakpoint\&.  
.PP
Definition at line \fB183\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
183 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.ResetCommand\fC [get]\fP, \fC [set]\fP"

.PP
Relay Command to Reset the Program back to its initial state\&.  
.PP
Definition at line \fB158\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
158 { get; set; }
.fi
.SS "\fBRomFileModel\fP Emulator\&.ViewModel\&.MainViewModel\&.RomFile\fC [get]\fP, \fC [set]\fP"

.PP
The currently loaded binary file\&. (If it is indeed loaded, that is\&.)  
.PP
Definition at line \fB92\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
92 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.RunPauseCommand\fC [get]\fP, \fC [set]\fP"

.PP
Relay Command that Run/Pauses Execution  
.PP
Definition at line \fB163\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
163 { get; set; }
.fi
.SS "\fBBreakpoint\fP Emulator\&.ViewModel\&.MainViewModel\&.SelectedBreakpoint\fC [get]\fP, \fC [set]\fP"

.PP
The Currently Selected Breakpoint  
.PP
Definition at line \fB87\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
87 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.SettingsCommand\fC [get]\fP, \fC [set]\fP"

.PP
The Command that loads or saves the settings\&.  
.PP
Definition at line \fB188\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
188 { get; set; }
.fi
.SS "\fBSettingsModel\fP Emulator\&.ViewModel\&.MainViewModel\&.SettingsModel\fC [static]\fP, \fC [get]\fP, \fC [set]\fP"

.PP
The \fBModel\fP used for saving, loading and using data from Settings\&.xml  
.PP
Definition at line \fB143\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
143 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.StepCommand\fC [get]\fP, \fC [set]\fP"

.PP
RelayCommand for Stepping through the progam one instruction at a time\&.  
.PP
Definition at line \fB148\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
148 { get; set; }
.fi
.SS "RelayCommand Emulator\&.ViewModel\&.MainViewModel\&.UpdateMemoryMapCommand\fC [get]\fP, \fC [set]\fP"

.PP
Relay Command that updates the Memory Map when the Page changes  
.PP
Definition at line \fB168\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
168 { get; set; }
.fi
.SS "\fBW65C02\fP Emulator\&.ViewModel\&.MainViewModel\&.W65C02\fC [get]\fP, \fC [private set]\fP"

.PP
The 65C02 Processor\&.  
.PP
Definition at line \fB42\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
42 { get; private set; }
.fi
.SS "\fBW65C22\fP Emulator\&.ViewModel\&.MainViewModel\&.W65C22\fC [get]\fP, \fC [private set]\fP"

.PP
General Purpose I/O, Shift Registers and Timers\&.  
.PP
Definition at line \fB47\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
47 { get; private set; }
.fi
.SS "\fBW65C51\fP Emulator\&.ViewModel\&.MainViewModel\&.W65C51\fC [get]\fP, \fC [private set]\fP"

.PP
The ACIA serial interface\&.  
.PP
Definition at line \fB57\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
57 { get; private set; }
.fi
.SS "string Emulator\&.ViewModel\&.MainViewModel\&.WindowTitle\fC [get]\fP"

.PP
The title for the main window\&.  
.PP
Definition at line \fB209\fP of file \fBMainViewModel\&.cs\fP\&.
.PP
.nf
209 { get { return Versioning\&.Product\&.Title; } }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for WolfNet 6502 WorkBench Computer Emulator from the source code\&.
