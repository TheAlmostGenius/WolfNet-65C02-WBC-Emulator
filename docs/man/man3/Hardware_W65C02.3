.TH "Hardware.W65C02" 3 "Wed Sep 28 2022" "Version beta" "WolfNet 6502 WorkBench Computer Emulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Hardware.W65C02 \- An implementation of a \fBW65C02\fP Processor\&.   

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBW65C02\fP ()"
.br
.RI "Default Constructor, Instantiates a new instance of the processor\&.  "
.ti -1c
.RI "void \fBReset\fP ()"
.br
.RI "Initializes the processor to its default state\&.  "
.ti -1c
.RI "void \fBNextStep\fP ()"
.br
.RI "Performs the next step on the processor  "
.ti -1c
.RI "void \fBInterruptRequest\fP ()"
.br
.RI "The InterruptRequest or IRQ  "
.ti -1c
.RI "int \fBGetCycleCount\fP ()"
.br
.RI "Gets the Number of Cycles that have elapsed  "
.ti -1c
.RI "void \fBIncrementCycleCount\fP ()"
.br
.RI "Increments the Cycle Count, causes a CycleCountIncrementedAction to fire\&.  "
.ti -1c
.RI "void \fBResetCycleCount\fP ()"
.br
.RI "Resets the Cycle Count back to 0  "
.ti -1c
.RI "void \fBAslOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ASL - Shift Left One Bit (Memory or Accumulator)  "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBisRunning\fP"
.br
.RI "Checks shether the emulated computer is running or not\&.  "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBSetNegativeFlag\fP (int value)"
.br
.RI "Sets the IsSignNegative register  "
.ti -1c
.RI "void \fBSetZeroFlag\fP (int value)"
.br
.RI "Sets the IsResultZero register  "
.ti -1c
.RI "int \fBGetAddressByAddressingMode\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "Uses the AddressingMode to return the correct address based on the mode\&. Note: This method will not increment the program counter for any mode\&. Note: This method will return an error if called for either the immediate or accumulator modes\&.  "
.ti -1c
.RI "void \fBAddWithCarryOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ADC - Add Memory to Accumulator with Carry Operation  "
.ti -1c
.RI "void \fBSubtractWithBorrowOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The SBC operation\&. Performs a subtract with carry operation on the accumulator and a value in memory\&.  "
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "int \fBAccumulator\fP\fC [get, protected set]\fP"
.br
.RI "The Accumulator\&. This value is implemented as an integer intead of a byte\&. This is done so we can detect wrapping of the value and set the correct number of cycles\&.  "
.ti -1c
.RI "int \fBXRegister\fP\fC [get, private set]\fP"
.br
.RI "The X Index Register  "
.ti -1c
.RI "int \fBYRegister\fP\fC [get, private set]\fP"
.br
.RI "The Y Index Register  "
.ti -1c
.RI "int \fBCurrentOpCode\fP\fC [get, private set]\fP"
.br
.RI "The Current Op Code being executed by the system  "
.ti -1c
.RI "\fBDisassembly\fP \fBCurrentDisassembly\fP\fC [get, private set]\fP"
.br
.RI "The disassembly of the current operation\&. This value is only set when the CPU is built in debug mode\&.  "
.ti -1c
.RI "int \fBProgramCounter\fP\fC [get, private set]\fP"
.br
.RI "Points to the Current Address of the instruction being executed by the system\&. The PC wraps when the value is greater than 65535, or less than 0\&.  "
.ti -1c
.RI "int \fBStackPointer\fP\fC [get, private set]\fP"
.br
.RI "Points to the Current Position of the Stack\&. This value is a 00-FF value but is offset to point to the location in memory where the stack resides\&.  "
.ti -1c
.RI "Action \fBCycleCountIncrementedAction\fP\fC [get, set]\fP"
.br
.RI "An external action that occurs when the cycle count is incremented  "
.ti -1c
.RI "bool \fBCarryFlag\fP\fC [get, protected set]\fP"
.br
.RI "This is the carry flag\&. when adding, if the result is greater than 255 or 99 in BCD Mode, then this bit is enabled\&. In subtraction this is reversed and set to false if a borrow is required IE the result is less than 0  "
.ti -1c
.RI "bool \fBZeroFlag\fP\fC [get, private set]\fP"
.br
.RI "Is true if one of the registers is set to zero\&.  "
.ti -1c
.RI "bool \fBDisableInterruptFlag\fP\fC [get, private set]\fP"
.br
.RI "This determines if Interrupts are currently disabled\&. This flag is turned on during a reset to prevent an interrupt from occuring during startup/Initialization\&. If this flag is true, then the IRQ pin is ignored\&.  "
.ti -1c
.RI "bool \fBDecimalFlag\fP\fC [get, private set]\fP"
.br
.RI "Binary Coded Decimal Mode is set/cleared via this flag\&. when this mode is in effect, a byte represents a number from 0-99\&.  "
.ti -1c
.RI "bool \fBOverflowFlag\fP\fC [get, protected set]\fP"
.br
.RI "This property is set when an overflow occurs\&. An overflow happens if the high bit(7) changes during the operation\&. Remember that values from 128-256 are negative values as the high bit is set to 1\&. Examples: 64 + 64 = -128 -128 + -128 = 0  "
.ti -1c
.RI "bool \fBNegativeFlag\fP\fC [get, private set]\fP"
.br
.RI "Set to true if the result of an operation is negative in ADC and SBC operations\&. Remember that 128-256 represent negative numbers when doing signed math\&. In shift operations the sign holds the carry\&.  "
.ti -1c
.RI "bool \fBTriggerNmi\fP\fC [get, set]\fP"
.br
.RI "Set to true when an NMI should occur  "
.ti -1c
.RI "bool \fBTriggerIRQ\fP\fC [get, private set]\fP"
.br
.RI "Set to true when an IRQ has occurred and is being processed by the CPU\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBExecuteOpCode\fP ()"
.br
.RI "Executes an Opcode  "
.ti -1c
.RI "void \fBMoveProgramCounterByRelativeValue\fP (byte valueToMove)"
.br
.RI "Moves the ProgramCounter in a given direction based on the value inputted "
.ti -1c
.RI "byte \fBPeekStack\fP ()"
.br
.RI "Returns a the value from the stack without changing the position of the stack pointer  "
.ti -1c
.RI "void \fBPokeStack\fP (byte value)"
.br
.RI "Write a value directly to the stack without modifying the Stack Pointer  "
.ti -1c
.RI "byte \fBConvertFlagsToByte\fP (bool setBreak)"
.br
.RI "Coverts the Flags into its byte representation\&.  "
.ti -1c
.RI "void \fBSetDisassembly\fP ()"
.br
.ti -1c
.RI "int \fBWrapProgramCounter\fP (int value)"
.br
.ti -1c
.RI "\fBAddressingMode\fP \fBGetAddressingMode\fP ()"
.br
.ti -1c
.RI "void \fBAndOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The AND - Compare Memory with Accumulator operation  "
.ti -1c
.RI "void \fBBranchOperation\fP (bool performBranch)"
.br
.RI "Performs the different branch operations\&.  "
.ti -1c
.RI "void \fBBitOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The bit operation, does an & comparison between a value in memory and the accumulator  "
.ti -1c
.RI "void \fBCompareOperation\fP (\fBAddressingMode\fP addressingMode, int comparisonValue)"
.br
.RI "The compare operation\&. This operation compares a value in memory with a value passed into it\&.  "
.ti -1c
.RI "void \fBChangeMemoryByOne\fP (\fBAddressingMode\fP addressingMode, bool decrement)"
.br
.RI "Changes a value in memory by 1  "
.ti -1c
.RI "void \fBChangeRegisterByOne\fP (bool useXRegister, bool decrement)"
.br
.RI "Changes a value in either the X or Y register by 1  "
.ti -1c
.RI "void \fBEorOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The EOR Operation, Performs an Exclusive OR Operation against the Accumulator and a value in memory  "
.ti -1c
.RI "void \fBLsrOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The LSR Operation\&. Performs a Left shift operation on a value in memory  "
.ti -1c
.RI "void \fBOrOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The Or Operation\&. Performs an Or Operation with the accumulator and a value in memory  "
.ti -1c
.RI "void \fBRolOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ROL operation\&. Performs a rotate left operation on a value in memory\&.  "
.ti -1c
.RI "void \fBRorOperation\fP (\fBAddressingMode\fP addressingMode)"
.br
.RI "The ROR operation\&. Performs a rotate right operation on a value in memory\&.  "
.ti -1c
.RI "void \fBPushFlagsOperation\fP ()"
.br
.RI "The PSP Operation\&. Pushes the Status Flags to the stack  "
.ti -1c
.RI "void \fBPullFlagsOperation\fP ()"
.br
.RI "The PLP Operation\&. Pull the status flags off the stack on sets the flags accordingly\&.  "
.ti -1c
.RI "void \fBJumpToSubRoutineOperation\fP ()"
.br
.RI "The JSR routine\&. Jumps to a subroutine\&.  "
.ti -1c
.RI "void \fBReturnFromSubRoutineOperation\fP ()"
.br
.RI "The RTS routine\&. Called when returning from a subroutine\&.  "
.ti -1c
.RI "void \fBBreakOperation\fP (bool isBrk, int vector)"
.br
.RI "The BRK routine\&. Called when a BRK occurs\&.  "
.ti -1c
.RI "void \fBReturnFromInterruptOperation\fP ()"
.br
.RI "The RTI routine\&. Called when returning from a BRK opertion\&. Note: when called after a BRK operation the Program Counter is not set to the location after the BRK, it is set +1  "
.ti -1c
.RI "void \fBProcessNMI\fP ()"
.br
.RI "This is ran anytime an NMI occurrs  "
.ti -1c
.RI "void \fBProcessIRQ\fP ()"
.br
.RI "This is ran anytime an IRQ occurrs  "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "readonly ILogger \fB_logger\fP = LogManager\&.GetLogger('Processor')"
.br
.ti -1c
.RI "int \fB_programCounter\fP"
.br
.ti -1c
.RI "int \fB_stackPointer\fP"
.br
.ti -1c
.RI "int \fB_cycleCount\fP"
.br
.ti -1c
.RI "bool \fB_previousInterrupt\fP"
.br
.ti -1c
.RI "bool \fB_interrupt\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
An implementation of a \fBW65C02\fP Processor\&.  
.PP
Definition at line \fB12\fP of file \fBW65C02\&.cs\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Hardware\&.W65C02\&.W65C02 ()\fC [inline]\fP"

.PP
Default Constructor, Instantiates a new instance of the processor\&.  
.PP
Definition at line \fB142\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
143         {
144             StackPointer = 0x100;
145             CycleCountIncrementedAction = () => { };
146         }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void Hardware\&.W65C02\&.AddWithCarryOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [protected]\fP"

.PP
The ADC - Add Memory to Accumulator with Carry Operation  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode used to perform this operation\&.
.RE
.PP

.PP
Definition at line \fB1883\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1884         {
1885             //Accumulator, Carry = Accumulator + ValueInMemoryLocation + Carry 
1886             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
1887             var newValue = memoryValue + Accumulator + (CarryFlag ? 1 : 0);
1888 
1889 
1890             OverflowFlag = (((Accumulator ^ newValue) & 0x80) != 0) && (((Accumulator ^ memoryValue) & 0x80) == 0);
1891 
1892             if (DecimalFlag)
1893             {
1894                 newValue = int\&.Parse(memoryValue\&.ToString("x")) + int\&.Parse(Accumulator\&.ToString("x")) + (CarryFlag ? 1 : 0);
1895 
1896                 if (newValue > 99)
1897                 {
1898                     CarryFlag = true;
1899                     newValue -= 100;
1900                 }
1901                 else
1902                 {
1903                     CarryFlag = false;
1904                 }
1905 
1906                 newValue = (int)Convert\&.ToInt64(string\&.Concat("0x", newValue), 16);
1907             }
1908             else
1909             {
1910                 if (newValue > 255)
1911                 {
1912                     CarryFlag = true;
1913                     newValue -= 256;
1914                 }
1915                 else
1916                 {
1917                     CarryFlag = false;
1918                 }
1919             }
1920 
1921             SetZeroFlag(newValue);
1922             SetNegativeFlag(newValue);
1923 
1924             Accumulator = newValue;
1925         }
.fi
.SS "void Hardware\&.W65C02\&.AndOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The AND - Compare Memory with Accumulator operation  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode being used
.RE
.PP

.PP
Definition at line \fB1931\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1932         {
1933             Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode)) & Accumulator;
1934 
1935             SetZeroFlag(Accumulator);
1936             SetNegativeFlag(Accumulator);
1937         }
.fi
.SS "void Hardware\&.W65C02\&.AslOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP"

.PP
The ASL - Shift Left One Bit (Memory or Accumulator)  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing Mode being used
.RE
.PP

.PP
Definition at line \fB1943\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1944         {
1945             int value;
1946             var memoryAddress = 0;
1947             if (addressingMode == AddressingMode\&.Accumulator)
1948             {
1949                 MemoryMap\&.Read(ProgramCounter + 1);
1950                 value = Accumulator;
1951             }
1952             else
1953             {
1954                 memoryAddress = GetAddressByAddressingMode(addressingMode);
1955                 value = MemoryMap\&.Read(memoryAddress);
1956             }
1957 
1958             //Dummy Write
1959             if (addressingMode != AddressingMode\&.Accumulator)
1960             {
1961                 MemoryMap\&.Write(memoryAddress, (byte)value);
1962             }
1963 
1964             //If the 7th bit is set, then we have a carry
1965             CarryFlag = ((value & 0x80) != 0);
1966 
1967             //The And here ensures that if the value is greater than 255 it wraps properly\&.
1968             value = (value << 1) & 0xFE;
1969 
1970             SetNegativeFlag(value);
1971             SetZeroFlag(value);
1972 
1973 
1974             if (addressingMode == AddressingMode\&.Accumulator)
1975                 Accumulator = value;
1976             else
1977             {
1978                 MemoryMap\&.Write(memoryAddress, (byte)value);
1979             }
1980         }
.fi
.SS "void Hardware\&.W65C02\&.BitOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The bit operation, does an & comparison between a value in memory and the accumulator  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP 
.RE
.PP

.PP
Definition at line \fB2003\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2004         {
2005 
2006             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2007             var valueToCompare = memoryValue & Accumulator;
2008 
2009             OverflowFlag = (memoryValue & 0x40) != 0;
2010 
2011             SetNegativeFlag(memoryValue);
2012             SetZeroFlag(valueToCompare);
2013         }
.fi
.SS "void Hardware\&.W65C02\&.BranchOperation (bool performBranch)\fC [inline]\fP, \fC [private]\fP"

.PP
Performs the different branch operations\&.  
.PP
\fBParameters\fP
.RS 4
\fIperformBranch\fP Is a branch required
.RE
.PP

.PP
Definition at line \fB1986\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1987         {
1988             var value = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Relative));
1989 
1990             if (!performBranch)
1991             {
1992                 ProgramCounter++;
1993                 return;
1994             }
1995 
1996             MoveProgramCounterByRelativeValue(value);
1997         }
.fi
.SS "void Hardware\&.W65C02\&.BreakOperation (bool isBrk, int vector)\fC [inline]\fP, \fC [private]\fP"

.PP
The BRK routine\&. Called when a BRK occurs\&.  
.PP
Definition at line \fB2349\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2350         {
2351             MemoryMap\&.Read(++ProgramCounter);
2352 
2353             //Put the high value on the stack
2354             //When we RTI the address will be incremented by one, and the address after a break will not be used\&.
2355             PokeStack((byte)(((ProgramCounter) >> 8) & 0xFF));
2356             StackPointer--;
2357             IncrementCycleCount();
2358 
2359             //Put the low value on the stack
2360             PokeStack((byte)((ProgramCounter) & 0xFF));
2361             StackPointer--;
2362             IncrementCycleCount();
2363 
2364             //We only set the Break Flag is a Break Occurs
2365             if (isBrk)
2366                 PokeStack((byte)(ConvertFlagsToByte(true) | 0x10));
2367             else
2368                 PokeStack(ConvertFlagsToByte(false));
2369 
2370             StackPointer--;
2371             IncrementCycleCount();
2372 
2373             DisableInterruptFlag = true;
2374 
2375             ProgramCounter = (MemoryMap\&.Read(vector + 1) << 8) | MemoryMap\&.Read(vector);
2376 
2377             _previousInterrupt = false;
2378         }
.fi
.SS "void Hardware\&.W65C02\&.ChangeMemoryByOne (\fBAddressingMode\fP addressingMode, bool decrement)\fC [inline]\fP, \fC [private]\fP"

.PP
Changes a value in memory by 1  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.br
\fIdecrement\fP If the operation is decrementing or incrementing the vaulue by 1 
.RE
.PP

.PP
Definition at line \fB2039\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2040         {
2041             var memoryLocation = GetAddressByAddressingMode(addressingMode);
2042             var memory = MemoryMap\&.Read(memoryLocation);
2043 
2044             MemoryMap\&.Write(memoryLocation, memory);
2045 
2046             if (decrement)
2047                 memory -= 1;
2048             else
2049                 memory += 1;
2050 
2051             SetZeroFlag(memory);
2052             SetNegativeFlag(memory);
2053 
2054 
2055             MemoryMap\&.Write(memoryLocation, memory);
2056         }
.fi
.SS "void Hardware\&.W65C02\&.ChangeRegisterByOne (bool useXRegister, bool decrement)\fC [inline]\fP, \fC [private]\fP"

.PP
Changes a value in either the X or Y register by 1  
.PP
\fBParameters\fP
.RS 4
\fIuseXRegister\fP If the operation is using the X or Y register
.br
\fIdecrement\fP If the operation is decrementing or incrementing the vaulue by 1 
.RE
.PP

.PP
Definition at line \fB2063\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2064         {
2065             var value = useXRegister ? XRegister : YRegister;
2066 
2067             if (decrement)
2068                 value -= 1;
2069             else
2070                 value += 1;
2071 
2072             if (value < 0x00)
2073                 value += 0x100;
2074             else if (value > 0xFF)
2075                 value -= 0x100;
2076 
2077             SetZeroFlag(value);
2078             SetNegativeFlag(value);
2079             IncrementCycleCount();
2080 
2081             if (useXRegister)
2082                 XRegister = value;
2083             else
2084                 YRegister = value;
2085         }
.fi
.SS "void Hardware\&.W65C02\&.CompareOperation (\fBAddressingMode\fP addressingMode, int comparisonValue)\fC [inline]\fP, \fC [private]\fP"

.PP
The compare operation\&. This operation compares a value in memory with a value passed into it\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.br
\fIcomparisonValue\fP The value to compare against memory
.RE
.PP

.PP
Definition at line \fB2020\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2021         {
2022             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2023             var comparedValue = comparisonValue - memoryValue;
2024 
2025             if (comparedValue < 0)
2026                 comparedValue += 0x10000;
2027 
2028             SetZeroFlag(comparedValue);
2029 
2030             CarryFlag = memoryValue <= comparisonValue;
2031             SetNegativeFlag(comparedValue);
2032         }
.fi
.SS "byte Hardware\&.W65C02\&.ConvertFlagsToByte (bool setBreak)\fC [inline]\fP, \fC [private]\fP"

.PP
Coverts the Flags into its byte representation\&.  
.PP
\fBParameters\fP
.RS 4
\fIsetBreak\fP Determines if the break flag should be set during conversion\&. IRQ does not set the flag on the stack, but PHP and BRK do
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB1521\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1522         {
1523             return (byte)((CarryFlag ? 0x01 : 0) + (ZeroFlag ? 0x02 : 0) + (DisableInterruptFlag ? 0x04 : 0) +
1524                 (DecimalFlag ? 8 : 0) + (setBreak ? 0x10 : 0) + 0x20 + (OverflowFlag ? 0x40 : 0) + (NegativeFlag ? 0x80 : 0));
1525         }
.fi
.SS "void Hardware\&.W65C02\&.EorOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The EOR Operation, Performs an Exclusive OR Operation against the Accumulator and a value in memory  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2091\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2092         {
2093             Accumulator = Accumulator ^ MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2094 
2095             SetNegativeFlag(Accumulator);
2096             SetZeroFlag(Accumulator);
2097         }
.fi
.SS "void Hardware\&.W65C02\&.ExecuteOpCode ()\fC [inline]\fP, \fC [private]\fP"

.PP
Executes an Opcode  
.PP
Definition at line \fB238\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
239         {
240             //The x+ cycles denotes that if a page wrap occurs, then an additional cycle is consumed\&.
241             //The x++ cycles denotes that 1 cycle is added when a branch occurs and it on the same page, and two cycles are added if its on a different page\&./
242             //This is handled inside the GetValueFromMemory Method
243             switch (CurrentOpCode)
244             {
245                 #region Add / Subtract Operations
246                 //ADC Add With Carry, Immediate, 2 Bytes, 2 Cycles
247                 case 0x69:
248                     {
249                         AddWithCarryOperation(AddressingMode\&.Immediate);
250                         break;
251                     }
252                 //ADC Add With Carry, Zero Page, 2 Bytes, 3 Cycles
253                 case 0x65:
254                     {
255                         AddWithCarryOperation(AddressingMode\&.ZeroPage);
256                         break;
257                     }
258                 //ADC Add With Carry, Zero Page X, 2 Bytes, 4 Cycles
259                 case 0x75:
260                     {
261                         AddWithCarryOperation(AddressingMode\&.ZeroPageX);
262                         break;
263                     }
264                 //ADC Add With Carry, Absolute, 3 Bytes, 4 Cycles
265                 case 0x6D:
266                     {
267                         AddWithCarryOperation(AddressingMode\&.Absolute);
268                         break;
269                     }
270                 //ADC Add With Carry, Absolute X, 3 Bytes, 4+ Cycles
271                 case 0x7D:
272                     {
273                         AddWithCarryOperation(AddressingMode\&.AbsoluteX);
274                         break;
275                     }
276                 //ADC Add With Carry, Absolute Y, 3 Bytes, 4+ Cycles
277                 case 0x79:
278                     {
279                         AddWithCarryOperation(AddressingMode\&.AbsoluteY);
280                         break;
281                     }
282                 //ADC Add With Carry, Indexed Indirect, 2 Bytes, 6 Cycles
283                 case 0x61:
284                     {
285                         AddWithCarryOperation(AddressingMode\&.IndirectX);
286                         break;
287                     }
288                 //ADC Add With Carry, Indexed Indirect, 2 Bytes, 5+ Cycles
289                 case 0x71:
290                     {
291                         AddWithCarryOperation(AddressingMode\&.IndirectY);
292                         break;
293                     }
294                 //SBC Subtract with Borrow, Immediate, 2 Bytes, 2 Cycles
295                 case 0xE9:
296                     {
297                         SubtractWithBorrowOperation(AddressingMode\&.Immediate);
298                         break;
299                     }
300                 //SBC Subtract with Borrow, Zero Page, 2 Bytes, 3 Cycles
301                 case 0xE5:
302                     {
303                         SubtractWithBorrowOperation(AddressingMode\&.ZeroPage);
304                         break;
305                     }
306                 //SBC Subtract with Borrow, Zero Page X, 2 Bytes, 4 Cycles
307                 case 0xF5:
308                     {
309                         SubtractWithBorrowOperation(AddressingMode\&.ZeroPageX);
310                         break;
311                     }
312                 //SBC Subtract with Borrow, Absolute, 3 Bytes, 4 Cycles
313                 case 0xED:
314                     {
315                         SubtractWithBorrowOperation(AddressingMode\&.Absolute);
316                         break;
317                     }
318                 //SBC Subtract with Borrow, Absolute X, 3 Bytes, 4+ Cycles
319                 case 0xFD:
320                     {
321                         SubtractWithBorrowOperation(AddressingMode\&.AbsoluteX);
322                         break;
323                     }
324                 //SBC Subtract with Borrow, Absolute Y, 3 Bytes, 4+ Cycles
325                 case 0xF9:
326                     {
327                         SubtractWithBorrowOperation(AddressingMode\&.AbsoluteY);
328                         break;
329                     }
330                 //SBC Subtract with Borrow, Indexed Indirect, 2 Bytes, 6 Cycles
331                 case 0xE1:
332                     {
333                         SubtractWithBorrowOperation(AddressingMode\&.IndirectX);
334                         break;
335                     }
336                 //SBC Subtract with Borrow, Indexed Indirect, 2 Bytes, 5+ Cycles
337                 case 0xF1:
338                     {
339                         SubtractWithBorrowOperation(AddressingMode\&.IndirectY);
340                         break;
341                     }
342                 #endregion
343 
344                 #region Branch Operations
345                 //BCC Branch if Carry is Clear, Relative, 2 Bytes, 2++ Cycles
346                 case 0x90:
347                     {
348                         BranchOperation(!CarryFlag);
349                         break;
350 
351                     }
352                 //BCS Branch if Carry is Set, Relative, 2 Bytes, 2++ Cycles
353                 case 0xB0:
354                     {
355                         BranchOperation(CarryFlag);
356                         break;
357                     }
358                 //BEQ Branch if Zero is Set, Relative, 2 Bytes, 2++ Cycles
359                 case 0xF0:
360                     {
361                         BranchOperation(ZeroFlag);
362                         break;
363                     }
364 
365                 // BMI Branch if Negative Set
366                 case 0x30:
367                     {
368                         BranchOperation(NegativeFlag);
369                         break;
370                     }
371                 //BNE Branch if Zero is Not Set, Relative, 2 Bytes, 2++ Cycles
372                 case 0xD0:
373                     {
374                         BranchOperation(!ZeroFlag);
375                         break;
376                     }
377                 // BPL Branch if Negative Clear, 2 Bytes, 2++ Cycles
378                 case 0x10:
379                     {
380                         BranchOperation(!NegativeFlag);
381                         break;
382                     }
383                 // BVC Branch if Overflow Clear, 2 Bytes, 2++ Cycles
384                 case 0x50:
385                     {
386                         BranchOperation(!OverflowFlag);
387                         break;
388                     }
389                 // BVS Branch if Overflow Set, 2 Bytes, 2++ Cycles
390                 case 0x70:
391                     {
392                         BranchOperation(OverflowFlag);
393                         break;
394                     }
395                 #endregion
396 
397                 #region BitWise Comparison Operations
398                 //AND Compare Memory with Accumulator, Immediate, 2 Bytes, 2 Cycles
399                 case 0x29:
400                     {
401                         AndOperation(AddressingMode\&.Immediate);
402                         break;
403                     }
404                 //AND Compare Memory with Accumulator, Zero Page, 2 Bytes, 3 Cycles
405                 case 0x25:
406                     {
407                         AndOperation(AddressingMode\&.ZeroPage);
408                         break;
409                     }
410                 //AND Compare Memory with Accumulator, Zero PageX, 2 Bytes, 3 Cycles
411                 case 0x35:
412                     {
413                         AndOperation(AddressingMode\&.ZeroPageX);
414                         break;
415                     }
416                 //AND Compare Memory with Accumulator, Absolute,  3 Bytes, 4 Cycles
417                 case 0x2D:
418                     {
419                         AndOperation(AddressingMode\&.Absolute);
420                         break;
421                     }
422                 //AND Compare Memory with Accumulator, AbsolueteX 3 Bytes, 4+ Cycles
423                 case 0x3D:
424                     {
425                         AndOperation(AddressingMode\&.AbsoluteX);
426                         break;
427                     }
428                 //AND Compare Memory with Accumulator, AbsoluteY, 3 Bytes, 4+ Cycles
429                 case 0x39:
430                     {
431                         AndOperation(AddressingMode\&.AbsoluteY);
432                         break;
433                     }
434                 //AND Compare Memory with Accumulator, IndexedIndirect, 2 Bytes, 6 Cycles
435                 case 0x21:
436                     {
437                         AndOperation(AddressingMode\&.IndirectX);
438                         break;
439                     }
440                 //AND Compare Memory with Accumulator, IndirectIndexed, 2 Bytes, 5 Cycles
441                 case 0x31:
442                     {
443                         AndOperation(AddressingMode\&.IndirectY);
444                         break;
445                     }
446                 //BIT Compare Memory with Accumulator, Zero Page, 2 Bytes, 3 Cycles
447                 case 0x24:
448                     {
449                         BitOperation(AddressingMode\&.ZeroPage);
450                         break;
451                     }
452                 //BIT Compare Memory with Accumulator, Absolute, 2 Bytes, 4 Cycles
453                 case 0x2C:
454                     {
455                         BitOperation(AddressingMode\&.Absolute);
456                         break;
457                     }
458                 //EOR Exclusive OR Memory with Accumulator, Immediate, 2 Bytes, 2 Cycles
459                 case 0x49:
460                     {
461                         EorOperation(AddressingMode\&.Immediate);
462                         break;
463                     }
464                 //EOR Exclusive OR Memory with Accumulator, Zero Page, 2 Bytes, 3 Cycles
465                 case 0x45:
466                     {
467                         EorOperation(AddressingMode\&.ZeroPage);
468                         break;
469                     }
470                 //EOR Exclusive OR Memory with Accumulator, Zero Page X, 2 Bytes, 4 Cycles
471                 case 0x55:
472                     {
473                         EorOperation(AddressingMode\&.ZeroPageX);
474                         break;
475                     }
476                 //EOR Exclusive OR Memory with Accumulator, Absolute, 3 Bytes, 4 Cycles
477                 case 0x4D:
478                     {
479                         EorOperation(AddressingMode\&.Absolute);
480                         break;
481                     }
482                 //EOR Exclusive OR Memory with Accumulator, Absolute X, 3 Bytes, 4+ Cycles
483                 case 0x5D:
484                     {
485                         EorOperation(AddressingMode\&.AbsoluteX);
486                         break;
487                     }
488                 //EOR Exclusive OR Memory with Accumulator, Absolute Y, 3 Bytes, 4+ Cycles
489                 case 0x59:
490                     {
491                         EorOperation(AddressingMode\&.AbsoluteY);
492                         break;
493                     }
494                 //EOR Exclusive OR Memory with Accumulator, IndexedIndirect, 2 Bytes 6 Cycles
495                 case 0x41:
496                     {
497                         EorOperation(AddressingMode\&.IndirectX);
498                         break;
499                     }
500                 //EOR Exclusive OR Memory with Accumulator, IndirectIndexed, 2 Bytes 5 Cycles
501                 case 0x51:
502                     {
503                         EorOperation(AddressingMode\&.IndirectY);
504                         break;
505                     }
506                 //ORA Compare Memory with Accumulator, Immediate, 2 Bytes, 2 Cycles
507                 case 0x09:
508                     {
509                         OrOperation(AddressingMode\&.Immediate);
510                         break;
511                     }
512                 //ORA Compare Memory with Accumulator, Zero Page, 2 Bytes, 2 Cycles
513                 case 0x05:
514                     {
515                         OrOperation(AddressingMode\&.ZeroPage);
516                         break;
517                     }
518                 //ORA Compare Memory with Accumulator, Zero PageX, 2 Bytes, 4 Cycles
519                 case 0x15:
520                     {
521                         OrOperation(AddressingMode\&.ZeroPageX);
522                         break;
523                     }
524                 //ORA Compare Memory with Accumulator, Absolute,  3 Bytes, 4 Cycles
525                 case 0x0D:
526                     {
527                         OrOperation(AddressingMode\&.Absolute);
528                         break;
529                     }
530                 //ORA Compare Memory with Accumulator, AbsolueteX 3 Bytes, 4+ Cycles
531                 case 0x1D:
532                     {
533                         OrOperation(AddressingMode\&.AbsoluteX);
534                         break;
535                     }
536                 //ORA Compare Memory with Accumulator, AbsoluteY, 3 Bytes, 4+ Cycles
537                 case 0x19:
538                     {
539                         OrOperation(AddressingMode\&.AbsoluteY);
540                         break;
541                     }
542                 //ORA Compare Memory with Accumulator, IndexedIndirect, 2 Bytes, 6 Cycles
543                 case 0x01:
544                     {
545                         OrOperation(AddressingMode\&.IndirectX);
546                         break;
547                     }
548                 //ORA Compare Memory with Accumulator, IndirectIndexed, 2 Bytes, 5 Cycles
549                 case 0x11:
550                     {
551                         OrOperation(AddressingMode\&.IndirectY);
552                         break;
553                     }
554                 #endregion
555 
556                 #region Clear Flag Operations
557                 //CLC Clear Carry Flag, Implied, 1 Byte, 2 Cycles
558                 case 0x18:
559                     {
560                         CarryFlag = false;
561                         IncrementCycleCount();
562                         break;
563                     }
564                 //CLD Clear Decimal Flag, Implied, 1 Byte, 2 Cycles
565                 case 0xD8:
566                     {
567                         DecimalFlag = false;
568                         IncrementCycleCount();
569                         break;
570 
571                     }
572                 //CLI Clear Interrupt Flag, Implied, 1 Byte, 2 Cycles
573                 case 0x58:
574                     {
575                         DisableInterruptFlag = false;
576                         IncrementCycleCount();
577                         break;
578 
579                     }
580                 //CLV Clear Overflow Flag, Implied, 1 Byte, 2 Cycles
581                 case 0xB8:
582                     {
583                         OverflowFlag = false;
584                         IncrementCycleCount();
585                         break;
586                     }
587 
588                 #endregion
589 
590                 #region Compare Operations
591                 //CMP Compare Accumulator with Memory, Immediate, 2 Bytes, 2 Cycles
592                 case 0xC9:
593                     {
594                         CompareOperation(AddressingMode\&.Immediate, Accumulator);
595                         break;
596                     }
597                 //CMP Compare Accumulator with Memory, Zero Page, 2 Bytes, 3 Cycles
598                 case 0xC5:
599                     {
600                         CompareOperation(AddressingMode\&.ZeroPage, Accumulator);
601                         break;
602                     }
603                 //CMP Compare Accumulator with Memory, Zero Page x, 2 Bytes, 4 Cycles
604                 case 0xD5:
605                     {
606                         CompareOperation(AddressingMode\&.ZeroPageX, Accumulator);
607                         break;
608                     }
609                 //CMP Compare Accumulator with Memory, Absolute, 3 Bytes, 4 Cycles
610                 case 0xCD:
611                     {
612                         CompareOperation(AddressingMode\&.Absolute, Accumulator);
613                         break;
614                     }
615                 //CMP Compare Accumulator with Memory, Absolute X, 2 Bytes, 4 Cycles
616                 case 0xDD:
617                     {
618                         CompareOperation(AddressingMode\&.AbsoluteX, Accumulator);
619                         break;
620                     }
621                 //CMP Compare Accumulator with Memory, Absolute Y, 2 Bytes, 4 Cycles
622                 case 0xD9:
623                     {
624                         CompareOperation(AddressingMode\&.AbsoluteY, Accumulator);
625                         break;
626                     }
627                 //CMP Compare Accumulator with Memory, Indirect X, 2 Bytes, 6 Cycles
628                 case 0xC1:
629                     {
630                         CompareOperation(AddressingMode\&.IndirectX, Accumulator);
631                         break;
632                     }
633                 //CMP Compare Accumulator with Memory, Indirect Y, 2 Bytes, 5 Cycles
634                 case 0xD1:
635                     {
636                         CompareOperation(AddressingMode\&.IndirectY, Accumulator);
637                         break;
638                     }
639                 //CPX Compare Accumulator with X Register, Immediate, 2 Bytes, 2 Cycles
640                 case 0xE0:
641                     {
642                         CompareOperation(AddressingMode\&.Immediate, XRegister);
643                         break;
644                     }
645                 //CPX Compare Accumulator with X Register, Zero Page, 2 Bytes, 3 Cycles
646                 case 0xE4:
647                     {
648                         CompareOperation(AddressingMode\&.ZeroPage, XRegister);
649                         break;
650                     }
651                 //CPX Compare Accumulator with X Register, Absolute, 3 Bytes, 4 Cycles
652                 case 0xEC:
653                     {
654                         CompareOperation(AddressingMode\&.Absolute, XRegister);
655                         break;
656                     }
657                 //CPY Compare Accumulator with Y Register, Immediate, 2 Bytes, 2 Cycles
658                 case 0xC0:
659                     {
660                         CompareOperation(AddressingMode\&.Immediate, YRegister);
661                         break;
662                     }
663                 //CPY Compare Accumulator with Y Register, Zero Page, 2 Bytes, 3 Cycles
664                 case 0xC4:
665                     {
666                         CompareOperation(AddressingMode\&.ZeroPage, YRegister);
667                         break;
668                     }
669                 //CPY Compare Accumulator with Y Register, Absolute, 3 Bytes, 4 Cycles
670                 case 0xCC:
671                     {
672                         CompareOperation(AddressingMode\&.Absolute, YRegister);
673                         break;
674                     }
675                 #endregion
676 
677                 #region Increment/Decrement Operations
678                 //DEC Decrement Memory by One, Zero Page, 2 Bytes, 5 Cycles
679                 case 0xC6:
680                     {
681                         ChangeMemoryByOne(AddressingMode\&.ZeroPage, true);
682                         break;
683                     }
684                 //DEC Decrement Memory by One, Zero Page X, 2 Bytes, 6 Cycles
685                 case 0xD6:
686                     {
687                         ChangeMemoryByOne(AddressingMode\&.ZeroPageX, true);
688                         break;
689                     }
690                 //DEC Decrement Memory by One, Absolute, 3 Bytes, 6 Cycles
691                 case 0xCE:
692                     {
693                         ChangeMemoryByOne(AddressingMode\&.Absolute, true);
694                         break;
695                     }
696                 //DEC Decrement Memory by One, Absolute X, 3 Bytes, 7 Cycles
697                 case 0xDE:
698                     {
699                         ChangeMemoryByOne(AddressingMode\&.AbsoluteX, true);
700                         IncrementCycleCount();
701                         break;
702                     }
703                 //DEX Decrement X Register by One, Implied, 1 Bytes, 2 Cycles
704                 case 0xCA:
705                     {
706                         ChangeRegisterByOne(true, true);
707                         break;
708                     }
709                 //DEY Decrement Y Register by One, Implied, 1 Bytes, 2 Cycles
710                 case 0x88:
711                     {
712                         ChangeRegisterByOne(false, true);
713                         break;
714                     }
715                 //INC Increment Memory by One, Zero Page, 2 Bytes, 5 Cycles
716                 case 0xE6:
717                     {
718                         ChangeMemoryByOne(AddressingMode\&.ZeroPage, false);
719                         break;
720                     }
721                 //INC Increment Memory by One, Zero Page X, 2 Bytes, 6 Cycles
722                 case 0xF6:
723                     {
724                         ChangeMemoryByOne(AddressingMode\&.ZeroPageX, false);
725                         break;
726                     }
727                 //INC Increment Memory by One, Absolute, 3 Bytes, 6 Cycles
728                 case 0xEE:
729                     {
730                         ChangeMemoryByOne(AddressingMode\&.Absolute, false);
731                         break;
732                     }
733                 //INC Increment Memory by One, Absolute X, 3 Bytes, 7 Cycles
734                 case 0xFE:
735                     {
736                         ChangeMemoryByOne(AddressingMode\&.AbsoluteX, false);
737                         IncrementCycleCount();
738                         break;
739                     }
740                 //INX Increment X Register by One, Implied, 1 Bytes, 2 Cycles
741                 case 0xE8:
742                     {
743                         ChangeRegisterByOne(true, false);
744                         break;
745                     }
746                 //INY Increment Y Register by One, Implied, 1 Bytes, 2 Cycles
747                 case 0xC8:
748                     {
749                         ChangeRegisterByOne(false, false);
750                         break;
751                     }
752                 #endregion
753 
754                 #region GOTO and GOSUB Operations
755                 //JMP Jump to New Location, Absolute 3 Bytes, 3 Cycles
756                 case 0x4C:
757                     {
758                         ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
759                         break;
760                     }
761                 //JMP Jump to New Location, Indirect 3 Bytes, 5 Cycles
762                 case 0x6C:
763                     {
764                         ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
765 
766                         if ((ProgramCounter & 0xFF) == 0xFF)
767                         {
768                             //Get the first half of the address
769                             int address = MemoryMap\&.Read(ProgramCounter);
770 
771                             //Get the second half of the address, due to the issue with page boundary it reads from the wrong location!
772                             address += 256 * MemoryMap\&.Read(ProgramCounter - 255);
773                             ProgramCounter = address;
774                         }
775                         else
776                         {
777                             ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
778                         }
779 
780                         break;
781                     }
782                 //JSR Jump to SubRoutine, Absolute, 3 Bytes, 6 Cycles
783                 case 0x20:
784                     {
785                         JumpToSubRoutineOperation();
786                         break;
787                     }
788                 //BRK Simulate IRQ, Implied, 1 Byte, 7 Cycles
789                 case 0x00:
790                     {
791                         BreakOperation(true, 0xFFFE);
792                         break;
793                     }
794                 //RTI Return From Interrupt, Implied, 1 Byte, 6 Cycles
795                 case 0x40:
796                     {
797                         ReturnFromInterruptOperation();
798                         break;
799                     }
800                 //RTS Return From Subroutine, Implied, 1 Byte, 6 Cycles
801                 case 0x60:
802                     {
803                         ReturnFromSubRoutineOperation();
804                         break;
805                     }
806                 #endregion
807 
808                 #region Load Value From Memory Operations
809                 //LDA Load Accumulator with Memory, Immediate, 2 Bytes, 2 Cycles
810                 case 0xA9:
811                     {
812                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Immediate));
813                         SetZeroFlag(Accumulator);
814                         SetNegativeFlag(Accumulator);
815                         break;
816                     }
817                 //LDA Load Accumulator with Memory, Zero Page, 2 Bytes, 3 Cycles
818                 case 0xA5:
819                     {
820                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPage));
821                         SetZeroFlag(Accumulator);
822                         SetNegativeFlag(Accumulator);
823                         break;
824                     }
825                 //LDA Load Accumulator with Memory, Zero Page X, 2 Bytes, 4 Cycles
826                 case 0xB5:
827                     {
828                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX));
829                         SetZeroFlag(Accumulator);
830                         SetNegativeFlag(Accumulator);
831                         break;
832                     }
833                 //LDA Load Accumulator with Memory, Absolute, 3 Bytes, 4 Cycles
834                 case 0xAD:
835                     {
836                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Absolute));
837                         SetZeroFlag(Accumulator);
838                         SetNegativeFlag(Accumulator);
839                         break;
840                     }
841                 //LDA Load Accumulator with Memory, Absolute X, 3 Bytes, 4+ Cycles
842                 case 0xBD:
843                     {
844                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteX));
845                         SetZeroFlag(Accumulator);
846                         SetNegativeFlag(Accumulator);
847                         break;
848                     }
849                 //LDA Load Accumulator with Memory, Absolute Y, 3 Bytes, 4+ Cycles
850                 case 0xB9:
851                     {
852                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteY));
853                         SetZeroFlag(Accumulator);
854                         SetNegativeFlag(Accumulator);
855                         break;
856                     }
857                 //LDA Load Accumulator with Memory, Index Indirect, 2 Bytes, 6 Cycles
858                 case 0xA1:
859                     {
860                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.IndirectX));
861                         SetZeroFlag(Accumulator);
862                         SetNegativeFlag(Accumulator);
863                         break;
864                     }
865                 //LDA Load Accumulator with Memory, Indirect Index, 2 Bytes, 5+ Cycles
866                 case 0xB1:
867                     {
868                         Accumulator = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.IndirectY));
869                         SetZeroFlag(Accumulator);
870                         SetNegativeFlag(Accumulator);
871                         break;
872                     }
873                 //LDX Load X with memory, Immediate, 2 Bytes, 2 Cycles
874                 case 0xA2:
875                     {
876                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Immediate));
877                         SetZeroFlag(XRegister);
878                         SetNegativeFlag(XRegister);
879                         break;
880                     }
881                 //LDX Load X with memory, Zero Page, 2 Bytes, 3 Cycles
882                 case 0xA6:
883                     {
884                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPage));
885                         SetZeroFlag(XRegister);
886                         SetNegativeFlag(XRegister);
887                         break;
888                     }
889                 //LDX Load X with memory, Zero Page Y, 2 Bytes, 4 Cycles
890                 case 0xB6:
891                     {
892                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPageY));
893                         SetZeroFlag(XRegister);
894                         SetNegativeFlag(XRegister);
895                         break;
896                     }
897                 //LDX Load X with memory, Absolute, 3 Bytes, 4 Cycles
898                 case 0xAE:
899                     {
900                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Absolute));
901                         SetZeroFlag(XRegister);
902                         SetNegativeFlag(XRegister);
903                         break;
904                     }
905                 //LDX Load X with memory, Absolute Y, 3 Bytes, 4+ Cycles
906                 case 0xBE:
907                     {
908                         XRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteY));
909                         SetZeroFlag(XRegister);
910                         SetNegativeFlag(XRegister);
911                         break;
912                     }
913                 //LDY Load Y with memory, Immediate, 2 Bytes, 2 Cycles
914                 case 0xA0:
915                     {
916                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Immediate));
917                         SetZeroFlag(YRegister);
918                         SetNegativeFlag(YRegister);
919                         break;
920                     }
921                 //LDY Load Y with memory, Zero Page, 2 Bytes, 3 Cycles
922                 case 0xA4:
923                     {
924                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPage));
925                         SetZeroFlag(YRegister);
926                         SetNegativeFlag(YRegister);
927                         break;
928                     }
929                 //LDY Load Y with memory, Zero Page X, 2 Bytes, 4 Cycles
930                 case 0xB4:
931                     {
932                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX));
933                         SetZeroFlag(YRegister);
934                         SetNegativeFlag(YRegister);
935                         break;
936                     }
937                 //LDY Load Y with memory, Absolute, 3 Bytes, 4 Cycles
938                 case 0xAC:
939                     {
940                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.Absolute));
941                         SetZeroFlag(YRegister);
942                         SetNegativeFlag(YRegister);
943                         break;
944                     }
945                 //LDY Load Y with memory, Absolue X, 3 Bytes, 4+ Cycles
946                 case 0xBC:
947                     {
948                         YRegister = MemoryMap\&.Read(GetAddressByAddressingMode(AddressingMode\&.AbsoluteX));
949                         SetZeroFlag(YRegister);
950                         SetNegativeFlag(YRegister);
951                         break;
952                     }
953                 #endregion
954 
955                 #region Push/Pull Stack
956                 //PHA Push Accumulator onto Stack, Implied, 1 Byte, 3 Cycles
957                 case 0x48:
958                     {
959                         MemoryMap\&.Read(ProgramCounter + 1);
960 
961                         PokeStack((byte)Accumulator);
962                         StackPointer--;
963                         IncrementCycleCount();
964                         break;
965 
966                     }
967                 //PHP Push Flags onto Stack, Implied, 1 Byte, 3 Cycles
968                 case 0x08:
969                     {
970                         MemoryMap\&.Read(ProgramCounter + 1);
971 
972                         PushFlagsOperation();
973                         StackPointer--;
974                         IncrementCycleCount();
975                         break;
976                     }
977                 //PLA Pull Accumulator from Stack, Implied, 1 Byte, 4 Cycles
978                 case 0x68:
979                     {
980                         MemoryMap\&.Read(ProgramCounter + 1);
981                         StackPointer++;
982                         IncrementCycleCount();
983 
984                         Accumulator = PeekStack();
985                         SetNegativeFlag(Accumulator);
986                         SetZeroFlag(Accumulator);
987 
988                         IncrementCycleCount();
989                         break;
990                     }
991                 //PLP Pull Flags from Stack, Implied, 1 Byte, 4 Cycles
992                 case 0x28:
993                     {
994                         MemoryMap\&.Read(ProgramCounter + 1);
995 
996                         StackPointer++;
997                         IncrementCycleCount();
998 
999                         PullFlagsOperation();
1000 
1001                         IncrementCycleCount();
1002                         break;
1003                     }
1004                 //TSX Transfer Stack Pointer to X Register, 1 Bytes, 2 Cycles
1005                 case 0xBA:
1006                     {
1007                         XRegister = StackPointer;
1008 
1009                         SetNegativeFlag(XRegister);
1010                         SetZeroFlag(XRegister);
1011                         IncrementCycleCount();
1012                         break;
1013                     }
1014                 //TXS Transfer X Register to Stack Pointer, 1 Bytes, 2 Cycles
1015                 case 0x9A:
1016                     {
1017                         StackPointer = (byte)XRegister;
1018                         IncrementCycleCount();
1019                         break;
1020                     }
1021                 #endregion
1022 
1023                 #region Set Flag Operations
1024                 //SEC Set Carry, Implied, 1 Bytes, 2 Cycles
1025                 case 0x38:
1026                     {
1027                         CarryFlag = true;
1028                         IncrementCycleCount();
1029                         break;
1030                     }
1031                 //SED Set Interrupt, Implied, 1 Bytes, 2 Cycles
1032                 case 0xF8:
1033                     {
1034                         DecimalFlag = true;
1035                         IncrementCycleCount();
1036                         break;
1037                     }
1038                 //SEI Set Interrupt, Implied, 1 Bytes, 2 Cycles
1039                 case 0x78:
1040                     {
1041                         DisableInterruptFlag = true;
1042                         IncrementCycleCount();
1043                         break;
1044                     }
1045                 #endregion
1046 
1047                 #region Shift/Rotate Operations
1048                 //ASL Shift Left 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1049                 case 0x0A:
1050                     {
1051                         AslOperation(AddressingMode\&.Accumulator);
1052                         break;
1053                     }
1054                 //ASL Shift Left 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1055                 case 0x06:
1056                     {
1057                         AslOperation(AddressingMode\&.ZeroPage);
1058                         break;
1059                     }
1060                 //ASL Shift Left 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1061                 case 0x16:
1062                     {
1063                         AslOperation(AddressingMode\&.ZeroPageX);
1064                         break;
1065                     }
1066                 //ASL Shift Left 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1067                 case 0x0E:
1068                     {
1069                         AslOperation(AddressingMode\&.Absolute);
1070                         break;
1071                     }
1072                 //ASL Shift Left 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1073                 case 0x1E:
1074                     {
1075                         AslOperation(AddressingMode\&.AbsoluteX);
1076                         IncrementCycleCount();
1077                         break;
1078                     }
1079                 //LSR Shift Left 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1080                 case 0x4A:
1081                     {
1082                         LsrOperation(AddressingMode\&.Accumulator);
1083                         break;
1084                     }
1085                 //LSR Shift Left 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1086                 case 0x46:
1087                     {
1088                         LsrOperation(AddressingMode\&.ZeroPage);
1089                         break;
1090                     }
1091                 //LSR Shift Left 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1092                 case 0x56:
1093                     {
1094                         LsrOperation(AddressingMode\&.ZeroPageX);
1095                         break;
1096                     }
1097                 //LSR Shift Left 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1098                 case 0x4E:
1099                     {
1100                         LsrOperation(AddressingMode\&.Absolute);
1101                         break;
1102                     }
1103                 //LSR Shift Left 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1104                 case 0x5E:
1105                     {
1106                         LsrOperation(AddressingMode\&.AbsoluteX);
1107                         IncrementCycleCount();
1108                         break;
1109                     }
1110                 //ROL Rotate Left 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1111                 case 0x2A:
1112                     {
1113                         RolOperation(AddressingMode\&.Accumulator);
1114                         break;
1115                     }
1116                 //ROL Rotate Left 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1117                 case 0x26:
1118                     {
1119                         RolOperation(AddressingMode\&.ZeroPage);
1120                         break;
1121                     }
1122                 //ROL Rotate Left 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1123                 case 0x36:
1124                     {
1125                         RolOperation(AddressingMode\&.ZeroPageX);
1126                         break;
1127                     }
1128                 //ROL Rotate Left 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1129                 case 0x2E:
1130                     {
1131                         RolOperation(AddressingMode\&.Absolute);
1132                         break;
1133                     }
1134                 //ROL Rotate Left 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1135                 case 0x3E:
1136                     {
1137                         RolOperation(AddressingMode\&.AbsoluteX);
1138                         IncrementCycleCount();
1139                         break;
1140                     }
1141                 //ROR Rotate Right 1 Bit Memory or Accumulator, Accumulator, 1 Bytes, 2 Cycles
1142                 case 0x6A:
1143                     {
1144                         RorOperation(AddressingMode\&.Accumulator);
1145                         break;
1146                     }
1147                 //ROR Rotate Right 1 Bit Memory or Accumulator, Zero Page, 2 Bytes, 5 Cycles
1148                 case 0x66:
1149                     {
1150                         RorOperation(AddressingMode\&.ZeroPage);
1151                         break;
1152                     }
1153                 //ROR Rotate Right 1 Bit Memory or Accumulator, Zero PageX, 2 Bytes, 6 Cycles
1154                 case 0x76:
1155                     {
1156                         RorOperation(AddressingMode\&.ZeroPageX);
1157                         break;
1158                     }
1159                 //ROR Rotate Right 1 Bit Memory or Accumulator, Absolute, 3 Bytes, 6 Cycles
1160                 case 0x6E:
1161                     {
1162                         RorOperation(AddressingMode\&.Absolute);
1163                         break;
1164                     }
1165                 //ROR Rotate Right 1 Bit Memory or Accumulator, AbsoluteX, 3 Bytes, 7 Cycles
1166                 case 0x7E:
1167                     {
1168                         RorOperation(AddressingMode\&.AbsoluteX);
1169                         IncrementCycleCount();
1170                         break;
1171                     }
1172                 #endregion
1173 
1174                 #region Store Value In Memory Operations
1175                 //STA Store Accumulator In Memory, Zero Page, 2 Bytes, 3 Cycles
1176                 case 0x85:
1177                     {
1178                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPage), (byte)Accumulator);
1179                         break;
1180                     }
1181                 //STA Store Accumulator In Memory, Zero Page X, 2 Bytes, 4 Cycles
1182                 case 0x95:
1183                     {
1184                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX), (byte)Accumulator);
1185                         break;
1186                     }
1187                 //STA Store Accumulator In Memory, Absolute, 3 Bytes, 4 Cycles
1188                 case 0x8D:
1189                     {
1190                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.Absolute), (byte)Accumulator);
1191                         break;
1192                     }
1193                 //STA Store Accumulator In Memory, Absolute X, 3 Bytes, 5 Cycles
1194                 case 0x9D:
1195                     {
1196                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.AbsoluteX), (byte)Accumulator);
1197                         IncrementCycleCount();
1198                         break;
1199                     }
1200                 //STA Store Accumulator In Memory, Absolute Y, 3 Bytes, 5 Cycles
1201                 case 0x99:
1202                     {
1203                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.AbsoluteY), (byte)Accumulator);
1204                         IncrementCycleCount();
1205                         break;
1206                     }
1207                 //STA Store Accumulator In Memory, Indexed Indirect, 2 Bytes, 6 Cycles
1208                 case 0x81:
1209                     {
1210                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.IndirectX), (byte)Accumulator);
1211                         break;
1212                     }
1213                 //STA Store Accumulator In Memory, Indirect Indexed, 2 Bytes, 6 Cycles
1214                 case 0x91:
1215                     {
1216                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.IndirectY), (byte)Accumulator);
1217                         IncrementCycleCount();
1218                         break;
1219                     }
1220                 //STX Store Index X, Zero Page, 2 Bytes, 3 Cycles
1221                 case 0x86:
1222                     {
1223                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPage), (byte)XRegister);
1224                         break;
1225                     }
1226                 //STX Store Index X, Zero Page Y, 2 Bytes, 4 Cycles
1227                 case 0x96:
1228                     {
1229                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPageY), (byte)XRegister);
1230                         break;
1231                     }
1232                 //STX Store Index X, Absolute, 3 Bytes, 4 Cycles
1233                 case 0x8E:
1234                     {
1235                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.Absolute), (byte)XRegister);
1236                         break;
1237                     }
1238                 //STY Store Index Y, Zero Page, 2 Bytes, 3 Cycles
1239                 case 0x84:
1240                     {
1241                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPage), (byte)YRegister);
1242                         break;
1243                     }
1244                 //STY Store Index Y, Zero Page X, 2 Bytes, 4 Cycles
1245                 case 0x94:
1246                     {
1247                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.ZeroPageX), (byte)YRegister);
1248                         break;
1249                     }
1250                 //STY Store Index Y, Absolute, 2 Bytes, 4 Cycles
1251                 case 0x8C:
1252                     {
1253                         MemoryMap\&.Write(GetAddressByAddressingMode(AddressingMode\&.Absolute), (byte)YRegister);
1254                         break;
1255                     }
1256                 #endregion
1257 
1258                 #region Transfer Operations
1259                 //TAX Transfer Accumulator to X Register, Implied, 1 Bytes, 2 Cycles
1260                 case 0xAA:
1261                     {
1262                         IncrementCycleCount();
1263                         XRegister = Accumulator;
1264 
1265                         SetNegativeFlag(XRegister);
1266                         SetZeroFlag(XRegister);
1267                         break;
1268                     }
1269                 //TAY Transfer Accumulator to Y Register, 1 Bytes, 2 Cycles
1270                 case 0xA8:
1271                     {
1272                         IncrementCycleCount();
1273                         YRegister = Accumulator;
1274 
1275                         SetNegativeFlag(YRegister);
1276                         SetZeroFlag(YRegister);
1277                         break;
1278                     }
1279                 //TXA Transfer X Register to Accumulator, Implied, 1 Bytes, 2 Cycles
1280                 case 0x8A:
1281                     {
1282                         IncrementCycleCount();
1283                         Accumulator = XRegister;
1284 
1285                         SetNegativeFlag(Accumulator);
1286                         SetZeroFlag(Accumulator);
1287                         break;
1288                     }
1289                 //TYA Transfer Y Register to Accumulator, Implied, 1 Bytes, 2 Cycles
1290                 case 0x98:
1291                     {
1292                         IncrementCycleCount();
1293                         Accumulator = YRegister;
1294 
1295                         SetNegativeFlag(Accumulator);
1296                         SetZeroFlag(Accumulator);
1297                         break;
1298                     }
1299                 #endregion
1300 
1301                 //NOP Operation, Implied, 1 Byte, 2 Cycles
1302                 case 0xEA:
1303                     {
1304                         IncrementCycleCount();
1305                         break;
1306                     }
1307 
1308                 default:
1309                     throw new NotSupportedException(string\&.Format("The OpCode {0} is not supported", CurrentOpCode));
1310             }
1311         }
.fi
.SS "int Hardware\&.W65C02\&.GetAddressByAddressingMode (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [protected]\fP"

.PP
Uses the AddressingMode to return the correct address based on the mode\&. Note: This method will not increment the program counter for any mode\&. Note: This method will return an error if called for either the immediate or accumulator modes\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing Mode to use
.RE
.PP
\fBReturns\fP
.RS 4
The memory Location
.RE
.PP

.PP
Definition at line \fB1339\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1340         {
1341             int address;
1342             int highByte;
1343             switch (addressingMode)
1344             {
1345                 case (AddressingMode\&.Absolute):
1346                     {
1347                         return (MemoryMap\&.Read(ProgramCounter++) | (MemoryMap\&.Read(ProgramCounter++) << 8));
1348                     }
1349                 case AddressingMode\&.AbsoluteX:
1350                     {
1351                         //Get the low half of the address
1352                         address = MemoryMap\&.Read(ProgramCounter++);
1353 
1354                         //Get the high byte
1355                         highByte = MemoryMap\&.Read(ProgramCounter++);
1356 
1357                         //We crossed a page boundry, so an extra read has occurred\&.
1358                         //However, if this is an ASL, LSR, DEC, INC, ROR, ROL or STA operation, we do not decrease it by 1\&.
1359                         if (address + XRegister > 0xFF)
1360                         {
1361                             switch (CurrentOpCode)
1362                             {
1363                                 case 0x1E:
1364                                 case 0xDE:
1365                                 case 0xFE:
1366                                 case 0x5E:
1367                                 case 0x3E:
1368                                 case 0x7E:
1369                                 case 0x9D:
1370                                     {
1371                                         //This is a MemoryMap\&.Read Fetch Write Operation, so we don't make the extra read\&.
1372                                         return ((highByte << 8 | address) + XRegister) & 0xFFFF;
1373                                     }
1374                                 default:
1375                                     {
1376                                         MemoryMap\&.Read((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);
1377                                         break;
1378                                     }
1379                             }
1380                         }
1381 
1382                         return ((highByte << 8 | address) + XRegister) & 0xFFFF;
1383                     }
1384                 case AddressingMode\&.AbsoluteY:
1385                     {
1386                         //Get the low half of the address
1387                         address = MemoryMap\&.Read(ProgramCounter++);
1388 
1389                         //Get the high byte
1390                         highByte = MemoryMap\&.Read(ProgramCounter++);
1391 
1392                         //We crossed a page boundry, so decrease the number of cycles by 1 if the operation is not STA
1393                         if (address + YRegister > 0xFF && CurrentOpCode != 0x99)
1394                         {
1395                             MemoryMap\&.Read((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);
1396                         }
1397 
1398                         //Bitshift the high byte into place, AND with FFFF to handle wrapping\&.
1399                         return ((highByte << 8 | address) + YRegister) & 0xFFFF;
1400                     }
1401                 case AddressingMode\&.Immediate:
1402                     {
1403                         return ProgramCounter++;
1404                     }
1405                 case AddressingMode\&.IndirectX:
1406                     {
1407                         //Get the location of the address to retrieve
1408                         address = MemoryMap\&.Read(ProgramCounter++);
1409                         MemoryMap\&.Read(address);
1410 
1411                         address += XRegister;
1412 
1413                         //Now get the final Address\&. The is not a zero page address either\&.
1414                         var finalAddress = MemoryMap\&.Read((address & 0xFF)) | (MemoryMap\&.Read((address + 1) & 0xFF) << 8);
1415                         return finalAddress;
1416                     }
1417                 case AddressingMode\&.IndirectY:
1418                     {
1419                         address = MemoryMap\&.Read(ProgramCounter++);
1420 
1421                         var finalAddress = MemoryMap\&.Read(address) + (MemoryMap\&.Read((address + 1) & 0xFF) << 8);
1422 
1423                         if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)
1424                         {
1425                             MemoryMap\&.Read((finalAddress + YRegister - 0xFF) & 0xFFFF);
1426                         }
1427 
1428                         return (finalAddress + YRegister) & 0xFFFF;
1429                     }
1430                 case AddressingMode\&.Relative:
1431                     {
1432                         return ProgramCounter;
1433                     }
1434                 case (AddressingMode\&.ZeroPage):
1435                     {
1436                         address = MemoryMap\&.Read(ProgramCounter++);
1437                         return address;
1438                     }
1439                 case (AddressingMode\&.ZeroPageX):
1440                     {
1441                         address = MemoryMap\&.Read(ProgramCounter++);
1442                         MemoryMap\&.Read(address);
1443 
1444                         address += XRegister;
1445                         address &= 0xFF;
1446 
1447                         //This address wraps if its greater than 0xFF
1448                         if (address > 0xFF)
1449                         {
1450                             address -= 0x100;
1451                             return address;
1452                         }
1453 
1454                         return address;
1455                     }
1456                 case (AddressingMode\&.ZeroPageY):
1457                     {
1458                         address = MemoryMap\&.Read(ProgramCounter++);
1459                         MemoryMap\&.Read(address);
1460 
1461                         address += YRegister;
1462                         address &= 0xFF;
1463 
1464                         return address;
1465                     }
1466                 default:
1467                     throw new InvalidOperationException(string\&.Format("The Address Mode '{0}' does not require an address", addressingMode));
1468             }
1469         }
.fi
.SS "\fBAddressingMode\fP Hardware\&.W65C02\&.GetAddressingMode ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB1680\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1681         {
1682             switch (CurrentOpCode)
1683             {
1684                 case 0x0D:  //ORA
1685                 case 0x2D:  //AND
1686                 case 0x4D:  //EOR
1687                 case 0x6D:  //ADC
1688                 case 0x8D:  //STA
1689                 case 0xAD:  //LDA
1690                 case 0xCD:  //CMP
1691                 case 0xED:  //SBC
1692                 case 0x0E:  //ASL
1693                 case 0x2E:  //ROL
1694                 case 0x4E:  //LSR
1695                 case 0x6E:  //ROR
1696                 case 0x8E:  //SDX
1697                 case 0xAE:  //LDX
1698                 case 0xCE:  //DEC
1699                 case 0xEE:  //INC
1700                 case 0x2C:  //Bit
1701                 case 0x4C:  //JMP
1702                 case 0x8C:  //STY
1703                 case 0xAC:  //LDY
1704                 case 0xCC:  //CPY
1705                 case 0xEC:  //CPX
1706                 case 0x20:  //JSR
1707                     {
1708                         return AddressingMode\&.Absolute;
1709                     }
1710                 case 0x1D:  //ORA
1711                 case 0x3D:  //AND
1712                 case 0x5D:  //EOR
1713                 case 0x7D:  //ADC
1714                 case 0x9D:  //STA
1715                 case 0xBD:  //LDA
1716                 case 0xDD:  //CMP
1717                 case 0xFD:  //SBC
1718                 case 0xBC:  //LDY
1719                 case 0xFE:  //INC
1720                 case 0x1E:  //ASL
1721                 case 0x3E:  //ROL
1722                 case 0x5E:  //LSR
1723                 case 0x7E:  //ROR
1724                     {
1725                         return AddressingMode\&.AbsoluteX;
1726                     }
1727                 case 0x19:  //ORA
1728                 case 0x39:  //AND
1729                 case 0x59:  //EOR
1730                 case 0x79:  //ADC
1731                 case 0x99:  //STA
1732                 case 0xB9:  //LDA
1733                 case 0xD9:  //CMP
1734                 case 0xF9:  //SBC
1735                 case 0xBE:  //LDX
1736                     {
1737                         return AddressingMode\&.AbsoluteY;
1738                     }
1739                 case 0x0A:  //ASL
1740                 case 0x4A:  //LSR
1741                 case 0x2A:  //ROL
1742                 case 0x6A:  //ROR
1743                     {
1744                         return AddressingMode\&.Accumulator;
1745                     }
1746 
1747                 case 0x09:  //ORA
1748                 case 0x29:  //AND
1749                 case 0x49:  //EOR
1750                 case 0x69:  //ADC
1751                 case 0xA0:  //LDY
1752                 case 0xC0:  //CPY
1753                 case 0xE0:  //CMP
1754                 case 0xA2:  //LDX
1755                 case 0xA9:  //LDA
1756                 case 0xC9:  //CMP
1757                 case 0xE9:  //SBC
1758                     {
1759                         return AddressingMode\&.Immediate;
1760                     }
1761                 case 0x00:  //BRK
1762                 case 0x18:  //CLC
1763                 case 0xD8:  //CLD
1764                 case 0x58:  //CLI
1765                 case 0xB8:  //CLV
1766                 case 0xDE:  //DEC
1767                 case 0xCA:  //DEX
1768                 case 0x88:  //DEY
1769                 case 0xE8:  //INX
1770                 case 0xC8:  //INY
1771                 case 0xEA:  //NOP
1772                 case 0x48:  //PHA
1773                 case 0x08:  //PHP
1774                 case 0x68:  //PLA
1775                 case 0x28:  //PLP
1776                 case 0x40:  //RTI
1777                 case 0x60:  //RTS
1778                 case 0x38:  //SEC
1779                 case 0xF8:  //SED
1780                 case 0x78:  //SEI
1781                 case 0xAA:  //TAX
1782                 case 0xA8:  //TAY
1783                 case 0xBA:  //TSX
1784                 case 0x8A:  //TXA
1785                 case 0x9A:  //TXS
1786                 case 0x98:  //TYA
1787                     {
1788                         return AddressingMode\&.Implied;
1789                     }
1790                 case 0x6C:
1791                     {
1792                         return AddressingMode\&.Indirect;
1793                     }
1794 
1795                 case 0x61:  //ADC
1796                 case 0x21:  //AND
1797                 case 0xC1:  //CMP
1798                 case 0x41:  //EOR
1799                 case 0xA1:  //LDA
1800                 case 0x01:  //ORA
1801                 case 0xE1:  //SBC
1802                 case 0x81:  //STA
1803                     {
1804                         return AddressingMode\&.IndirectX;
1805                     }
1806                 case 0x71:  //ADC
1807                 case 0x31:  //AND
1808                 case 0xD1:  //CMP
1809                 case 0x51:  //EOR
1810                 case 0xB1:  //LDA
1811                 case 0x11:  //ORA
1812                 case 0xF1:  //SBC
1813                 case 0x91:  //STA
1814                     {
1815                         return AddressingMode\&.IndirectY;
1816                     }
1817                 case 0x90:  //BCC
1818                 case 0xB0:  //BCS
1819                 case 0xF0:  //BEQ
1820                 case 0x30:  //BMI
1821                 case 0xD0:  //BNE
1822                 case 0x10:  //BPL
1823                 case 0x50:  //BVC
1824                 case 0x70:  //BVS
1825                     {
1826                         return AddressingMode\&.Relative;
1827                     }
1828                 case 0x65:  //ADC
1829                 case 0x25:  //AND
1830                 case 0x06:  //ASL
1831                 case 0x24:  //BIT
1832                 case 0xC5:  //CMP
1833                 case 0xE4:  //CPX
1834                 case 0xC4:  //CPY
1835                 case 0xC6:  //DEC
1836                 case 0x45:  //EOR
1837                 case 0xE6:  //INC
1838                 case 0xA5:  //LDA
1839                 case 0xA6:  //LDX
1840                 case 0xA4:  //LDY
1841                 case 0x46:  //LSR
1842                 case 0x05:  //ORA
1843                 case 0x26:  //ROL
1844                 case 0x66:  //ROR
1845                 case 0xE5:  //SBC
1846                 case 0x85:  //STA
1847                 case 0x86:  //STX
1848                 case 0x84:  //STY
1849                     {
1850                         return AddressingMode\&.ZeroPage;
1851                     }
1852                 case 0x75:  //ADC
1853                 case 0x35:  //AND
1854                 case 0x16:  //ASL
1855                 case 0xD5:  //CMP
1856                 case 0xD6:  //DEC
1857                 case 0x55:  //EOR
1858                 case 0xF6:  //INC
1859                 case 0xB5:  //LDA
1860                 case 0xB6:  //LDX
1861                 case 0xB4:  //LDY
1862                 case 0x56:  //LSR
1863                 case 0x15:  //ORA
1864                 case 0x36:  //ROL
1865                 case 0x76:  //ROR
1866                 case 0xF5:  //SBC
1867                 case 0x95:  //STA
1868                 case 0x96:  //STX
1869                 case 0x94:  //STY
1870                     {
1871                         return AddressingMode\&.ZeroPageX;
1872                     }
1873                 default:
1874                     throw new NotSupportedException(string\&.Format("Opcode {0} is not supported", CurrentOpCode));
1875             }
1876         }
.fi
.SS "int Hardware\&.W65C02\&.GetCycleCount ()\fC [inline]\fP"

.PP
Gets the Number of Cycles that have elapsed  
.PP
\fBReturns\fP
.RS 4
The number of elapsed cycles
.RE
.PP

.PP
Definition at line \fB208\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
209         {
210             return _cycleCount;
211         }
.fi
.SS "void Hardware\&.W65C02\&.IncrementCycleCount ()\fC [inline]\fP"

.PP
Increments the Cycle Count, causes a CycleCountIncrementedAction to fire\&.  
.PP
Definition at line \fB216\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
217         {
218             _cycleCount++;
219             CycleCountIncrementedAction();
220 
221             _previousInterrupt = _interrupt;
222             _interrupt = TriggerNmi || (TriggerIRQ && !DisableInterruptFlag);
223         }
.fi
.SS "void Hardware\&.W65C02\&.InterruptRequest ()\fC [inline]\fP"

.PP
The InterruptRequest or IRQ  
.PP
Definition at line \fB199\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
200         {
201             TriggerIRQ = true;
202         }
.fi
.SS "void Hardware\&.W65C02\&.JumpToSubRoutineOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The JSR routine\&. Jumps to a subroutine\&.  
.PP
Definition at line \fB2308\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2309         {
2310             IncrementCycleCount();
2311 
2312             //Put the high value on the stack, this should be the address after our operation -1
2313             //The RTS operation increments the PC by 1 which is why we don't move 2
2314             PokeStack((byte)(((ProgramCounter + 1) >> 8) & 0xFF));
2315             StackPointer--;
2316             IncrementCycleCount();
2317 
2318             PokeStack((byte)((ProgramCounter + 1) & 0xFF));
2319             StackPointer--;
2320             IncrementCycleCount();
2321 
2322             ProgramCounter = GetAddressByAddressingMode(AddressingMode\&.Absolute);
2323         }
.fi
.SS "void Hardware\&.W65C02\&.LsrOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The LSR Operation\&. Performs a Left shift operation on a value in memory  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2103\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2104         {
2105             int value;
2106             var memoryAddress = 0;
2107             if (addressingMode == AddressingMode\&.Accumulator)
2108             {
2109                 MemoryMap\&.Read(ProgramCounter + 1);
2110                 value = Accumulator;
2111             }
2112             else
2113             {
2114                 memoryAddress = GetAddressByAddressingMode(addressingMode);
2115                 value = MemoryMap\&.Read(memoryAddress);
2116             }
2117 
2118             //Dummy Write
2119             if (addressingMode != AddressingMode\&.Accumulator)
2120             {
2121                 MemoryMap\&.Write(memoryAddress, (byte)value);
2122             }
2123 
2124             NegativeFlag = false;
2125 
2126             //If the Zero bit is set, we have a carry
2127             CarryFlag = (value & 0x01) != 0;
2128 
2129             value = (value >> 1);
2130 
2131             SetZeroFlag(value);
2132             if (addressingMode == AddressingMode\&.Accumulator)
2133                 Accumulator = value;
2134             else
2135             {
2136                 MemoryMap\&.Write(memoryAddress, (byte)value);
2137             }
2138         }
.fi
.SS "void Hardware\&.W65C02\&.MoveProgramCounterByRelativeValue (byte valueToMove)\fC [inline]\fP, \fC [private]\fP"

.PP
Moves the ProgramCounter in a given direction based on the value inputted 
.PP
Definition at line \fB1475\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1476         {
1477             var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;
1478 
1479             var newProgramCounter = ProgramCounter + movement;
1480 
1481             //This makes sure that we always land on the correct spot for a positive number
1482             if (movement >= 0)
1483                 newProgramCounter++;
1484 
1485             //We Crossed a Page Boundary\&. So we increment the cycle counter by one\&. The +1 is because we always check from the end of the instruction not the beginning
1486             if (((ProgramCounter + 1 ^ newProgramCounter) & 0xff00) != 0x0000)
1487             {
1488                 IncrementCycleCount();
1489             }
1490 
1491             ProgramCounter = newProgramCounter;
1492             MemoryMap\&.Read(ProgramCounter);
1493         }
.fi
.SS "void Hardware\&.W65C02\&.NextStep ()\fC [inline]\fP"

.PP
Performs the next step on the processor  
.PP
Definition at line \fB170\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
171         {
172             SetDisassembly();
173 
174             //Have to read this first otherwise it causes tests to fail on a NES
175             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
176 
177             ProgramCounter++;
178 
179             ExecuteOpCode();
180 
181             if (_previousInterrupt)
182             {
183                 if (TriggerNmi)
184                 {
185                     ProcessNMI();
186                     TriggerNmi = false;
187                 }
188                 else if (TriggerIRQ)
189                 {
190                     ProcessIRQ();
191                     TriggerIRQ = false;
192                 }
193             }
194         }
.fi
.SS "void Hardware\&.W65C02\&.OrOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The Or Operation\&. Performs an Or Operation with the accumulator and a value in memory  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2144\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2145         {
2146             Accumulator = Accumulator | MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2147 
2148             SetNegativeFlag(Accumulator);
2149             SetZeroFlag(Accumulator);
2150         }
.fi
.SS "byte Hardware\&.W65C02\&.PeekStack ()\fC [inline]\fP, \fC [private]\fP"

.PP
Returns a the value from the stack without changing the position of the stack pointer  
.PP
\fBReturns\fP
.RS 4
The value at the current Stack Pointer
.RE
.PP

.PP
Definition at line \fB1499\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1500         {
1501             //The stack lives at 0x100-0x1FF, but the value is only a byte so it needs to be translated
1502             return MemoryMap\&.Read(StackPointer + 0x100);
1503         }
.fi
.SS "void Hardware\&.W65C02\&.PokeStack (byte value)\fC [inline]\fP, \fC [private]\fP"

.PP
Write a value directly to the stack without modifying the Stack Pointer  
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The value to be written to the stack
.RE
.PP

.PP
Definition at line \fB1510\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1511         {
1512             //The stack lives at 0x100-0x1FF, but the value is only a byte so it needs to be translated
1513             MemoryMap\&.Write(StackPointer + 0x100, value);
1514         }
.fi
.SS "void Hardware\&.W65C02\&.ProcessIRQ ()\fC [inline]\fP, \fC [private]\fP"

.PP
This is ran anytime an IRQ occurrs  
.PP
Definition at line \fB2420\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2421         {
2422             if (DisableInterruptFlag)
2423                 return;
2424 
2425             ProgramCounter--;
2426             BreakOperation(false, 0xFFFE);
2427             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
2428 
2429             SetDisassembly();
2430         }
.fi
.SS "void Hardware\&.W65C02\&.ProcessNMI ()\fC [inline]\fP, \fC [private]\fP"

.PP
This is ran anytime an NMI occurrs  
.PP
Definition at line \fB2408\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2409         {
2410             ProgramCounter--;
2411             BreakOperation(false, 0xFFFA);
2412             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
2413 
2414             SetDisassembly();
2415         }
.fi
.SS "void Hardware\&.W65C02\&.PullFlagsOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The PLP Operation\&. Pull the status flags off the stack on sets the flags accordingly\&.  
.PP
Definition at line \fB2292\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2293         {
2294             var flags = PeekStack();
2295             CarryFlag = (flags & 0x01) != 0;
2296             ZeroFlag = (flags & 0x02) != 0;
2297             DisableInterruptFlag = (flags & 0x04) != 0;
2298             DecimalFlag = (flags & 0x08) != 0;
2299             OverflowFlag = (flags & 0x40) != 0;
2300             NegativeFlag = (flags & 0x80) != 0;
2301 
2302 
2303         }
.fi
.SS "void Hardware\&.W65C02\&.PushFlagsOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The PSP Operation\&. Pushes the Status Flags to the stack  
.PP
Definition at line \fB2284\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2285         {
2286             PokeStack(ConvertFlagsToByte(true));
2287         }
.fi
.SS "void Hardware\&.W65C02\&.Reset ()\fC [inline]\fP"

.PP
Initializes the processor to its default state\&.  
.PP
Definition at line \fB151\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
152         {
153             ResetCycleCount();
154             StackPointer = 0x1FD;
155             //Set the Program Counter to the Reset Vector Address\&.
156             ProgramCounter = 0xFFFC;
157             //Reset the Program Counter to the Address contained in the Reset Vector
158             ProgramCounter = (MemoryMap\&.Read(ProgramCounter) | (MemoryMap\&.Read(ProgramCounter + 1) << 8));
159             CurrentOpCode = MemoryMap\&.Read(ProgramCounter);
160             //SetDisassembly();
161             DisableInterruptFlag = true;
162             _previousInterrupt = false;
163             TriggerNmi = false;
164             TriggerIRQ = false;
165         }
.fi
.SS "void Hardware\&.W65C02\&.ResetCycleCount ()\fC [inline]\fP"

.PP
Resets the Cycle Count back to 0  
.PP
Definition at line \fB228\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
229         {
230             _cycleCount = 0;
231         }
.fi
.SS "void Hardware\&.W65C02\&.ReturnFromInterruptOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The RTI routine\&. Called when returning from a BRK opertion\&. Note: when called after a BRK operation the Program Counter is not set to the location after the BRK, it is set +1  
.PP
Definition at line \fB2385\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2386         {
2387             MemoryMap\&.Read(++ProgramCounter);
2388             StackPointer++;
2389             IncrementCycleCount();
2390 
2391             PullFlagsOperation();
2392             StackPointer++;
2393             IncrementCycleCount();
2394 
2395             var lowBit = PeekStack();
2396             StackPointer++;
2397             IncrementCycleCount();
2398 
2399             var highBit = PeekStack() << 8;
2400             IncrementCycleCount();
2401 
2402             ProgramCounter = (highBit | lowBit);
2403         }
.fi
.SS "void Hardware\&.W65C02\&.ReturnFromSubRoutineOperation ()\fC [inline]\fP, \fC [private]\fP"

.PP
The RTS routine\&. Called when returning from a subroutine\&.  
.PP
Definition at line \fB2328\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2329         {
2330             MemoryMap\&.Read(++ProgramCounter);
2331             StackPointer++;
2332             IncrementCycleCount();
2333 
2334             var lowBit = PeekStack();
2335             StackPointer++;
2336             IncrementCycleCount();
2337 
2338             var highBit = PeekStack() << 8;
2339             IncrementCycleCount();
2340 
2341             ProgramCounter = (highBit | lowBit) + 1;
2342             IncrementCycleCount();
2343         }
.fi
.SS "void Hardware\&.W65C02\&.RolOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The ROL operation\&. Performs a rotate left operation on a value in memory\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2156\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2157         {
2158             int value;
2159             var memoryAddress = 0;
2160             if (addressingMode == AddressingMode\&.Accumulator)
2161             {
2162                 //Dummy MemoryMap\&.Read
2163                 MemoryMap\&.Read(ProgramCounter + 1);
2164                 value = Accumulator;
2165             }
2166             else
2167             {
2168                 memoryAddress = GetAddressByAddressingMode(addressingMode);
2169                 value = MemoryMap\&.Read(memoryAddress);
2170             }
2171 
2172             //Dummy Write
2173             if (addressingMode != AddressingMode\&.Accumulator)
2174             {
2175                 MemoryMap\&.Write(memoryAddress, (byte)value);
2176             }
2177 
2178             //Store the carry flag before shifting it
2179             var newCarry = (0x80 & value) != 0;
2180 
2181             //The And here ensures that if the value is greater than 255 it wraps properly\&.
2182             value = (value << 1) & 0xFE;
2183 
2184             if (CarryFlag)
2185                 value = value | 0x01;
2186 
2187             CarryFlag = newCarry;
2188 
2189             SetZeroFlag(value);
2190             SetNegativeFlag(value);
2191 
2192 
2193             if (addressingMode == AddressingMode\&.Accumulator)
2194                 Accumulator = value;
2195             else
2196             {
2197                 MemoryMap\&.Write(memoryAddress, (byte)value);
2198             }
2199         }
.fi
.SS "void Hardware\&.W65C02\&.RorOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [private]\fP"

.PP
The ROR operation\&. Performs a rotate right operation on a value in memory\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2205\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2206         {
2207             int value;
2208             var memoryAddress = 0;
2209             if (addressingMode == AddressingMode\&.Accumulator)
2210             {
2211                 //Dummy MemoryMap\&.Read
2212                 MemoryMap\&.Read(ProgramCounter + 1);
2213                 value = Accumulator;
2214             }
2215             else
2216             {
2217                 memoryAddress = GetAddressByAddressingMode(addressingMode);
2218                 value = MemoryMap\&.Read(memoryAddress);
2219             }
2220 
2221             //Dummy Write
2222             if (addressingMode != AddressingMode\&.Accumulator)
2223             {
2224                 MemoryMap\&.Write(memoryAddress, (byte)value);
2225             }
2226 
2227             //Store the carry flag before shifting it
2228             var newCarry = (0x01 & value) != 0;
2229 
2230             value = (value >> 1);
2231 
2232             //If the carry flag is set then 0x
2233             if (CarryFlag)
2234                 value = value | 0x80;
2235 
2236             CarryFlag = newCarry;
2237 
2238             SetZeroFlag(value);
2239             SetNegativeFlag(value);
2240 
2241             if (addressingMode == AddressingMode\&.Accumulator)
2242                 Accumulator = value;
2243             else
2244             {
2245                 MemoryMap\&.Write(memoryAddress, (byte)value);
2246             }
2247         }
.fi
.SS "void Hardware\&.W65C02\&.SetDisassembly ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB1527\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1528         {
1529             var addressMode = GetAddressingMode();
1530 
1531             var currentProgramCounter = ProgramCounter;
1532 
1533             currentProgramCounter = WrapProgramCounter(++currentProgramCounter);
1534             int? address1 = MemoryMap\&.Read(currentProgramCounter);
1535 
1536             currentProgramCounter = WrapProgramCounter(++currentProgramCounter);
1537             int? address2 = MemoryMap\&.Read(currentProgramCounter);
1538 
1539             string disassembledStep = string\&.Empty;
1540 
1541             switch (addressMode)
1542             {
1543                 case AddressingMode\&.Absolute:
1544                     {
1545                         disassembledStep = string\&.Format("${0}{1}", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1546                         break;
1547                     }
1548                 case AddressingMode\&.AbsoluteX:
1549                     {
1550                         disassembledStep = string\&.Format("${0}{1},X", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1551                         break;
1552                     }
1553                 case AddressingMode\&.AbsoluteY:
1554                     {
1555                         disassembledStep = string\&.Format("${0}{1},Y", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1556                         break;
1557                     }
1558                 case AddressingMode\&.Accumulator:
1559                     {
1560                         address1 = null;
1561                         address2 = null;
1562 
1563                         disassembledStep = "A";
1564                         break;
1565                     }
1566                 case AddressingMode\&.Immediate:
1567                     {
1568                         disassembledStep = string\&.Format("#${0}", address1\&.Value\&.ToString("X")\&.PadLeft(4, '0'));
1569                         address2 = null;
1570                         break;
1571                     }
1572                 case AddressingMode\&.Implied:
1573                     {
1574                         address1 = null;
1575                         address2 = null;
1576                         break;
1577                     }
1578                 case AddressingMode\&.Indirect:
1579                     {
1580                         disassembledStep = string\&.Format("(${0}{1})", address2\&.Value\&.ToString("X")\&.PadLeft(2, '0'), address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1581                         break;
1582                     }
1583                 case AddressingMode\&.IndirectX:
1584                     {
1585                         address2 = null;
1586 
1587                         disassembledStep = string\&.Format("(${0},X)", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1588                         break;
1589                     }
1590                 case AddressingMode\&.IndirectY:
1591                     {
1592                         address2 = null;
1593 
1594                         disassembledStep = string\&.Format("(${0}),Y", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1595                         break;
1596                     }
1597                 case AddressingMode\&.Relative:
1598                     {
1599                         var valueToMove = (byte)address1\&.Value;
1600 
1601                         var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;
1602 
1603                         var newProgramCounter = ProgramCounter + movement;
1604 
1605                         //This makes sure that we always land on the correct spot for a positive number
1606                         if (movement >= 0)
1607                             newProgramCounter++;
1608 
1609                         var stringAddress = ProgramCounter\&.ToString("X")\&.PadLeft(4, '0');
1610 
1611                         address1 = int\&.Parse(stringAddress\&.Substring(0, 2), NumberStyles\&.AllowHexSpecifier);
1612                         address2 = int\&.Parse(stringAddress\&.Substring(2, 2), NumberStyles\&.AllowHexSpecifier);
1613 
1614                         disassembledStep = string\&.Format("${0}", newProgramCounter\&.ToString("X")\&.PadLeft(4, '0'));
1615 
1616                         break;
1617                     }
1618                 case AddressingMode\&.ZeroPage:
1619                     {
1620                         address2 = null;
1621 
1622                         disassembledStep = string\&.Format("${0}", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1623                         break;
1624                     }
1625                 case AddressingMode\&.ZeroPageX:
1626                     {
1627                         address2 = null;
1628 
1629                         disassembledStep = string\&.Format("${0},X", address1\&.Value\&.ToString("X")\&.PadLeft(2, '0'));
1630                         break;
1631                     }
1632                 case AddressingMode\&.ZeroPageY:
1633                     {
1634                         address2 = null;
1635 
1636                         disassembledStep = string\&.Format("${0},Y", address1\&.Value\&.ToString("X")\&.PadLeft(4, '0'));
1637                         break;
1638                     }
1639                 default:
1640                     throw new InvalidEnumArgumentException("Invalid Addressing Mode");
1641 
1642             }
1643 
1644 
1645             CurrentDisassembly = new Disassembly
1646             {
1647                 HighAddress = address2\&.HasValue ? address2\&.Value\&.ToString("X")\&.PadLeft(2, '0') : string\&.Empty,
1648                 LowAddress = address1\&.HasValue ? address1\&.Value\&.ToString("X")\&.PadLeft(2, '0') : string\&.Empty,
1649                 OpCodeString = CurrentOpCode\&.ConvertOpCodeIntoString(),
1650                 DisassemblyOutput = disassembledStep
1651             };
1652 
1653             _logger\&.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}",
1654                  ProgramCounter\&.ToString("X")\&.PadLeft(4, '0'),
1655                  CurrentOpCode\&.ToString("X")\&.PadLeft(2, '0'),
1656                  CurrentDisassembly\&.LowAddress,
1657                  CurrentDisassembly\&.HighAddress,
1658 
1659                  CurrentDisassembly\&.OpCodeString,
1660                  CurrentDisassembly\&.DisassemblyOutput\&.PadRight(10, ' '),
1661 
1662                  Accumulator\&.ToString("X")\&.PadLeft(3, '0'),
1663                      XRegister\&.ToString("X")\&.PadLeft(3, '0'),
1664                      YRegister\&.ToString("X")\&.PadLeft(3, '0'),
1665                      StackPointer\&.ToString("X")\&.PadLeft(3, '0'),
1666                      Convert\&.ToInt16(NegativeFlag),
1667                      Convert\&.ToInt16(OverflowFlag),
1668                      0,
1669                      Convert\&.ToInt16(DecimalFlag),
1670                      Convert\&.ToInt16(DisableInterruptFlag),
1671                      Convert\&.ToInt16(ZeroFlag),
1672                      Convert\&.ToInt16(CarryFlag));
1673         }
.fi
.SS "void Hardware\&.W65C02\&.SetNegativeFlag (int value)\fC [inline]\fP, \fC [protected]\fP"

.PP
Sets the IsSignNegative register  
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP 
.RE
.PP

.PP
Definition at line \fB1317\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1318         {
1319             //on the 6502, any value greater than 127 is negative\&. 128 = 1000000 in Binary\&. the 8th bit is set, therefore the number is a negative number\&.
1320             NegativeFlag = value > 127;
1321         }
.fi
.SS "void Hardware\&.W65C02\&.SetZeroFlag (int value)\fC [inline]\fP, \fC [protected]\fP"

.PP
Sets the IsResultZero register  
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP 
.RE
.PP

.PP
Definition at line \fB1327\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1328         {
1329             ZeroFlag = value == 0;
1330         }
.fi
.SS "void Hardware\&.W65C02\&.SubtractWithBorrowOperation (\fBAddressingMode\fP addressingMode)\fC [inline]\fP, \fC [protected]\fP"

.PP
The SBC operation\&. Performs a subtract with carry operation on the accumulator and a value in memory\&.  
.PP
\fBParameters\fP
.RS 4
\fIaddressingMode\fP The addressing mode to use
.RE
.PP

.PP
Definition at line \fB2253\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
2254         {
2255             var memoryValue = MemoryMap\&.Read(GetAddressByAddressingMode(addressingMode));
2256             var newValue = DecimalFlag ? int\&.Parse(Accumulator\&.ToString("x")) - int\&.Parse(memoryValue\&.ToString("x")) - (CarryFlag ? 0 : 1) : Accumulator - memoryValue - (CarryFlag ? 0 : 1);
2257 
2258             CarryFlag = newValue >= 0;
2259 
2260             if (DecimalFlag)
2261             {
2262                 if (newValue < 0)
2263                     newValue += 100;
2264 
2265                 newValue = (int)Convert\&.ToInt64(string\&.Concat("0x", newValue), 16);
2266             }
2267             else
2268             {
2269                 OverflowFlag = (((Accumulator ^ newValue) & 0x80) != 0) && (((Accumulator ^ memoryValue) & 0x80) != 0);
2270 
2271                 if (newValue < 0)
2272                     newValue += 256;
2273             }
2274 
2275             SetNegativeFlag(newValue);
2276             SetZeroFlag(newValue);
2277 
2278             Accumulator = newValue;
2279         }
.fi
.SS "int Hardware\&.W65C02\&.WrapProgramCounter (int value)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB1675\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
1676         {
1677             return value & 0xFFFF;
1678         }
.fi
.SH "Member Data Documentation"
.PP 
.SS "int Hardware\&.W65C02\&._cycleCount\fC [private]\fP"

.PP
Definition at line \fB18\fP of file \fBW65C02\&.cs\fP\&.
.SS "bool Hardware\&.W65C02\&._interrupt\fC [private]\fP"

.PP
Definition at line \fB20\fP of file \fBW65C02\&.cs\fP\&.
.SS "readonly ILogger Hardware\&.W65C02\&._logger = LogManager\&.GetLogger('Processor')\fC [private]\fP"

.PP
Definition at line \fB15\fP of file \fBW65C02\&.cs\fP\&.
.SS "bool Hardware\&.W65C02\&._previousInterrupt\fC [private]\fP"

.PP
Definition at line \fB19\fP of file \fBW65C02\&.cs\fP\&.
.SS "int Hardware\&.W65C02\&._programCounter\fC [private]\fP"

.PP
Definition at line \fB16\fP of file \fBW65C02\&.cs\fP\&.
.SS "int Hardware\&.W65C02\&._stackPointer\fC [private]\fP"

.PP
Definition at line \fB17\fP of file \fBW65C02\&.cs\fP\&.
.SS "bool Hardware\&.W65C02\&.isRunning"

.PP
Checks shether the emulated computer is running or not\&.  
.PP
Definition at line \fB25\fP of file \fBW65C02\&.cs\fP\&.
.SH "Property Documentation"
.PP 
.SS "int Hardware\&.W65C02\&.Accumulator\fC [get]\fP, \fC [protected set]\fP"

.PP
The Accumulator\&. This value is implemented as an integer intead of a byte\&. This is done so we can detect wrapping of the value and set the correct number of cycles\&.  
.PP
Definition at line \fB33\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
33 { get; protected set; }
.fi
.SS "bool Hardware\&.W65C02\&.CarryFlag\fC [get]\fP, \fC [protected set]\fP"

.PP
This is the carry flag\&. when adding, if the result is greater than 255 or 99 in BCD Mode, then this bit is enabled\&. In subtraction this is reversed and set to false if a borrow is required IE the result is less than 0  
.PP
Definition at line \fB93\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
93 { get; protected set; }
.fi
.SS "\fBDisassembly\fP Hardware\&.W65C02\&.CurrentDisassembly\fC [get]\fP, \fC [private set]\fP"

.PP
The disassembly of the current operation\&. This value is only set when the CPU is built in debug mode\&.  
.PP
Definition at line \fB53\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
53 { get; private set; }
.fi
.SS "int Hardware\&.W65C02\&.CurrentOpCode\fC [get]\fP, \fC [private set]\fP"

.PP
The Current Op Code being executed by the system  
.PP
Definition at line \fB48\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
48 { get; private set; }
.fi
.SS "Action Hardware\&.W65C02\&.CycleCountIncrementedAction\fC [get]\fP, \fC [set]\fP"

.PP
An external action that occurs when the cycle count is incremented  
.PP
Definition at line \fB86\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
86 { get; set; }
.fi
.SS "bool Hardware\&.W65C02\&.DecimalFlag\fC [get]\fP, \fC [private set]\fP"

.PP
Binary Coded Decimal Mode is set/cleared via this flag\&. when this mode is in effect, a byte represents a number from 0-99\&.  
.PP
Definition at line \fB111\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
111 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.DisableInterruptFlag\fC [get]\fP, \fC [private set]\fP"

.PP
This determines if Interrupts are currently disabled\&. This flag is turned on during a reset to prevent an interrupt from occuring during startup/Initialization\&. If this flag is true, then the IRQ pin is ignored\&.  
.PP
Definition at line \fB105\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
105 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.NegativeFlag\fC [get]\fP, \fC [private set]\fP"

.PP
Set to true if the result of an operation is negative in ADC and SBC operations\&. Remember that 128-256 represent negative numbers when doing signed math\&. In shift operations the sign holds the carry\&.  
.PP
Definition at line \fB127\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
127 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.OverflowFlag\fC [get]\fP, \fC [protected set]\fP"

.PP
This property is set when an overflow occurs\&. An overflow happens if the high bit(7) changes during the operation\&. Remember that values from 128-256 are negative values as the high bit is set to 1\&. Examples: 64 + 64 = -128 -128 + -128 = 0  
.PP
Definition at line \fB120\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
120 { get; protected set; }
.fi
.SS "int Hardware\&.W65C02\&.ProgramCounter\fC [get]\fP, \fC [private set]\fP"

.PP
Points to the Current Address of the instruction being executed by the system\&. The PC wraps when the value is greater than 65535, or less than 0\&.  
.PP
Definition at line \fB59\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
60         {
61             get { return _programCounter; }
62             private set { _programCounter = WrapProgramCounter(value); }
63         }
.fi
.SS "int Hardware\&.W65C02\&.StackPointer\fC [get]\fP, \fC [private set]\fP"

.PP
Points to the Current Position of the Stack\&. This value is a 00-FF value but is offset to point to the location in memory where the stack resides\&.  
.PP
Definition at line \fB69\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
70         {
71             get { return _stackPointer; }
72             private set
73             {
74                 if (value > 0xFF)
75                     _stackPointer = value - 0x100;
76                 else if (value < 0x00)
77                     _stackPointer = value + 0x100;
78                 else
79                     _stackPointer = value;
80             }
81         }
.fi
.SS "bool Hardware\&.W65C02\&.TriggerIRQ\fC [get]\fP, \fC [private set]\fP"

.PP
Set to true when an IRQ has occurred and is being processed by the CPU\&. 
.PP
Definition at line \fB135\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
135 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.TriggerNmi\fC [get]\fP, \fC [set]\fP"

.PP
Set to true when an NMI should occur  
.PP
Definition at line \fB132\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
132 { get; set; }
.fi
.SS "int Hardware\&.W65C02\&.XRegister\fC [get]\fP, \fC [private set]\fP"

.PP
The X Index Register  
.PP
Definition at line \fB38\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
38 { get; private set; }
.fi
.SS "int Hardware\&.W65C02\&.YRegister\fC [get]\fP, \fC [private set]\fP"

.PP
The Y Index Register  
.PP
Definition at line \fB43\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
43 { get; private set; }
.fi
.SS "bool Hardware\&.W65C02\&.ZeroFlag\fC [get]\fP, \fC [private set]\fP"

.PP
Is true if one of the registers is set to zero\&.  
.PP
Definition at line \fB98\fP of file \fBW65C02\&.cs\fP\&.
.PP
.nf
98 { get; private set; }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for WolfNet 6502 WorkBench Computer Emulator from the source code\&.
